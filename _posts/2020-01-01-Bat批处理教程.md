---
layout: post
title: Bat批处理教程
date: 2020-01-01
tags: Bat批处理教程
---

# 批处理基础知识

## echo、@ 和 pause 命令

### echo

echo命令用来显示此命令后的字符。echo语法如下。
```bat
echo [on|off] [message]
```

参数：
- on  off指定是否允许命令的回显。若要显示当前的echo的设置，可使用不带参数的echo命令。
- message指定让MS_DOS在屏幕上显示正文。

实例：下面实例将在DOS控制台中输出“hello bat”
```bat
@echo off
echo hello bat
pause
```
脚本说明：

@ 表示将不在DOS中显示echo off 命令；

echo off 表示后续命令在DOS中不显示；

echo hello bat 表示将在DOS中显示“hello bat”字符串；

pause 表示脚本执行完后，不立即关闭DOS窗口，而是提示“请按任意键继续...”信息。当用户按了任意键，DOS窗口将关闭。

结果如下
```
hello bat
请按任意键继续. . .
```

在运行下面批处理程序时，MS-DOS一般在屏幕上显示（回显）批处理程序中的命令，如下：
```bat
echo hello bat
pause
```
运行结果：
```
D:\MDPro\bat>echo hello bat
hello bat

D:\MDPro\bat>pause
请按任意键继续. . .
```

上面实例中，echo off 表示在此语句后所有运行的命令都不在DOS中显示。但是，echo off命令本身将会显示出来。如果你不想显示 echo off 命令，可以在 echo off 前面添加 @ 符号。

### @ (命令行回显屏蔽符)

@ 符号的作用是屏蔽批处理程序中执行的命令在DOS窗口显示（即在DOS中不显示执行的命令）。实例如下：
```bat
@echo hello bat
@pause
```
运行结果：
```bat
hello bat
请按任意键继续. . .
```

### @ 和 echo off 配合

@符号与 echo off 相似，均是用来屏蔽命令在DOS中输出。但 @ 符号是加在每个命令行的最前面，表示运行时不显示这一行的命令（只能影响当前行）。而 echo off 则是隐藏该命令后面的所有命令（但是不影响 echo off 命令）。实例：

```bat
@echo off
echo hello bat
pause
```

这样就完美解决了命令在DOS窗口回显问题。如果只使用 @ ,每个命令都要添加 @ 符号，很不友好；仅仅使用 echo off，而 echo off 命令还是被显示。

### pause

运行 pause 语句会暂停批处理的执行并在屏幕上显示“Press any key to contineu...” 或 “请按任意键继续...”的提示，等待用户按任意键后继续。实例
```bat
pause
```

运行结果
```
D:\MDPro\bat>pause
请按任意键继续. . .
```

实例：用户按两下任意键，关闭DOS窗口。
```bat
@echo off
pause
pause
```

运行结果
```
请按任意键继续. . .
请按任意键继续. . .
```


## 批处理注释

一个好的脚本注释是必要的。注释是用来对脚本功能的说明，添加注释能提高脚本的可读性，注释是不会被执行的。

- rem
- 其他形式的注释

### rem

rem 在批处理文件中加入注解，也可用REM命令来屏蔽命令。语法
```bat
REM[string]
```

参数：
- string 指定要屏蔽的命令或要包含的注解。

实例：使用rem命令添加注释和屏蔽命令“echo hello”

```bat
@echo off
rem 我是一行注释
rem echo hello
pause
```

运行结果
```
请按任意键继续. . .
```

### 其他形式的注释

下面实例演示了其他形式的注释，也能实现注释的功能。如下：

```bat
@echo off
 
rem 段注释一种比较常用的方法
goto start
= 可以是多行文本，可以是命令
= 可以包含重定向符号和其他特殊字符
= 只要不包含 :start 这一行，就都是注释
:start
 
:: 注释内容（第一个冒号后也可以跟任何一个非字母数字的字符）
 
echo 注释内容（不能出现重定向符号和管道符号）> nul
 
if not exist nul 注释内容（不能出现重定向符号和管道符号）
 
:注释内容（注释文本不能与已有标签重名）
 
rem 可以用作行间注释，不能出现重定向符号和管道符号
%注释内容%
 
goto 标签 注释内容（可以用作说明goto的条件和执行内容）
:标签 注释内容（可以用作标签下方段的执行内容）
 
pause
```

运行结果：
```
请按任意键继续. . .
```

## 重定向符 > 和 >>

在bat中，重定向符号（ > 和 >> ）用于将某条命令的输出写到指定的地方，如写入到文件、nul(空设备)。

- '>'
- '>>'
- 屏蔽批处理错误

### >

在批处理中 > 符号实现重定向，可将命令的输出写入到指定的文件、nul（nul是空设备名，像个黑洞，往往用来屏蔽错误输出等）等位置。

注意： > 符会覆盖文件中已有的内容。

实例：将ping命令的输出信息输出到ping.txt文件。如下
```bat
@echo off
ping www.baidu.com > ping.txt
ping www.hxstrive.com > ping.txt
echo finished
pause
```

运行结果如下：
```
正在 Ping www.hxstrive.com [39.99.59.199] 具有 32 字节的数据:
来自 39.99.59.199 的回复: 字节=32 时间=65ms TTL=51
来自 39.99.59.199 的回复: 字节=32 时间=55ms TTL=51
来自 39.99.59.199 的回复: 字节=32 时间=95ms TTL=51
来自 39.99.59.199 的回复: 字节=32 时间=73ms TTL=51

39.99.59.199 的 Ping 统计信息:
    数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，
往返行程的估计时间(以毫秒为单位):
    最短 = 55ms，最长 = 95ms，平均 = 72ms
```

上面实例中，执行了两条ping命令。在ping.txt文件中只保存了最后一条ping命令的结果，上一次结果被后面的ping覆盖了。

### >>

'>>' 符号和 '>' 符号作用类似，也可将命令的输出写入到指定的文件、nul等，唯一不同的是，>> 符号会将当前命令的结果直接追加到指定文件的最后面。

实例：将ping命令的输出信息输出到ping.txt文件。如下
```bat
@echo off
ping www.baidu.com >> ping.txt
ping www.hxstrive.com >> ping.txt
echo finished
pause
```

运行结果如下：
```
正在 Ping www.a.shifen.com [14.215.177.38] 具有 32 字节的数据:
来自 14.215.177.38 的回复: 字节=32 时间=3ms TTL=55
来自 14.215.177.38 的回复: 字节=32 时间=4ms TTL=55
来自 14.215.177.38 的回复: 字节=32 时间=3ms TTL=55
来自 14.215.177.38 的回复: 字节=32 时间=5ms TTL=55

14.215.177.38 的 Ping 统计信息:
    数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，
往返行程的估计时间(以毫秒为单位):
    最短 = 3ms，最长 = 5ms，平均 = 3ms

正在 Ping www.hxstrive.com [39.99.59.199] 具有 32 字节的数据:
来自 39.99.59.199 的回复: 字节=32 时间=55ms TTL=51
来自 39.99.59.199 的回复: 字节=32 时间=55ms TTL=51
来自 39.99.59.199 的回复: 字节=32 时间=55ms TTL=51
来自 39.99.59.199 的回复: 字节=32 时间=55ms TTL=51

39.99.59.199 的 Ping 统计信息:
    数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，
往返行程的估计时间(以毫秒为单位):
    最短 = 55ms，最长 = 55ms，平均 = 55ms
```

上面实例中，执行了两条ping命令。在ping.txt文件中保存有两条ping命令的结果。

### 屏蔽批处理错误

加入我们需要使用批处理执行copy命令拷贝文件到指定目录。如下：

```bat
@echo off
copy a.txt bak/b.txt
if %errorlevel%==0 (
    echo SUCCESS
) else (
    echo ERROR
)
pause
```

运行结果
```
系统找不到指定的文件。
ERROR
请按任意键继续. . .
```

如果不小心将copy错误的写成了copu。如下

```bat
@echo off
copu a.txt bak/b.txt
if %errorlevel%==0 (
    echo SUCCESS
) else (
    echo ERROR
)
pause
```

运行结果：
```
'copu' 不是内部或外部命令，也不是可运行的程序
或批处理文件。
ERROR
请按任意键继续. . .
```

上面的结果中输出了“'copu' 不是内部或外部命令，也不是可运行的程序
或批处理文件。”错误信息。我们可以使用重定向符号隐藏这个错误信息，如下：
```bat
@echo off
copu a.txt bak/b.txt >nul 2>nul
if %errorlevel%==0 (
    echo SUCCESS
) else (
    echo ERROR
)
pause
```

运行结果：
```
ERROR
请按任意键继续. . .
```

上面的输出结果并没有输出copu命令执行的错误信息，只显示我们echo给出的提示信息。其中：>nul 2>nul 就是把命令执行的输出信息和错误信息不输出到屏幕，而是输出到一个根本不存在的设备。>nul等效于 1>nul, >nul前面的1表示输出流，2表示错误流（1可以省略不写）

### 常见设备名：
- con控制台（键盘和显示器）
- aux , com1 - com4 所有串口
- prn , lpt1 - lpt3 所有并口
- nul 空设备
- clock$ 电子钟

实例：将输出信息和错误信息重定向到con设备，如下：
```bat
@echo off
copu a.txt bak/b.txt >con 2>con
if %errorlevel%==0 (
    echo SUCCESS
) else (
    echo ERROR
)
pause
```

运行结果和不添加 >con 2>con 结果一致
```
'copu' 不是内部或外部命令，也不是可运行的程序
或批处理文件。
ERROR
请按任意键继续. . .
```

### 总结

'>'和'>>'符号均可以将命令输出结果输入到指定的文件、nul设备等。其中，> 符号将会覆盖文件旧的内容； >> 符号不会覆盖文件旧的内容，直接将结果写入文件末尾。

## 批处理文件参数

将介绍批处理程序中怎样传递参数，接收参数。批处理程序中可引用的参数为 %0 ~ %9，%0 是指批处理文件的本身，也可以说是一个外部命令；%1 ~ %9 是批处理参数。
实例演示：
```bat
@echo off
echo param0=%0
echo param1=%1
echo param2=%2
echo param3=%3
echo param4=%4
echo param5=%5
echo param6=%6
echo param7=%7
echo param8=%8
echo param9=%9
pause
```

运行及运行结果
```
G:\MDPro\bat>helloworld.bat a b c d e f g h i

param0=helloworld.bat
param1=a
param2=b
param3=c
param4=d
param5=e
param6=f
param7=g
param8=h
param9=i
请按任意键继续. . .
```

### 接收多于 %1 ~ %9 个参数

上面我们了解到批处理文件中可引用的参数为 %0 ~ %9，%0 是指批处理文件的本身；%1 ~ %9 是批处理参数，也称形参；而替换形参的实参若超过了批处理文件中所规定数值（9个）且想在批处理文件中应用这些实参的话， shift 命令可以帮你实现，查看更多shift命令信息。
```
C:\Users\SL-zhuji>shift /?
更改批处理文件中可替换参数的位置。

SHIFT [/n]

如果命令扩展被启用，SHIFT 命令支持/n 命令行开关；该命令行开关告诉
命令从第 n 个参数开始移位；n 介于零和八之间。例如:

    SHIFT /2

会将 %3 移位到 %2，将 %4 移位到 %3，等等；并且不影响 %0 和 %1。
```


实例：演示怎样使用 shift 命令接收更多参数。如下
```bat
@echo off
echo %1 %2 %3 %4 %5 %6 %7 %8 %9
shift /0
echo %1 %2 %3 %4 %5 %6 %7 %8 %9
shift /1
echo %1 %2 %3 %4 %5 %6 %7 %8 %9
shift /2
echo %1 %2 %3 %4 %5 %6 %7 %8 %9
shift /3
echo %1 %2 %3 %4 %5 %6 %7 %8 %9
shift /4
echo %1 %2 %3 %4 %5 %6 %7 %8 %9
shift /5
echo %1 %2 %3 %4 %5 %6 %7 %8 %9
shift /6
echo %1 %2 %3 %4 %5 %6 %7 %8 %9
shift /7
echo %1 %2 %3 %4 %5 %6 %7 %8 %9
shift /8
echo %1 %2 %3 %4 %5 %6 %7 %8 %9
pause
```

运行及运行结果
```
G:\MDPro\bat>helloworld.bat a b c d e f g h i j k l m n o p q r s t u v w x y z

a b c d e f g h i
b c d e f g h i j
c d e f g h i j k
c e f g h i j k l
c e g h i j k l m
c e g i j k l m n
c e g i k l m n o
c e g i k m n o p
c e g i k m o p q
c e g i k m o q r
请按任意键继续. . .
```

### 总结

- 如果不借助其他命令，批处理最多接收9个额外的参数（%1 ~ %9）。
- 使用 shift 命令可以对参数进行偏移，从而取到更多参数。
- 如果使用的某个参数没有传递过来，则该变量为空。

## errorlevel基础用法

本文将介绍批处理文件中 errorlevel 与 %errorlevel% 的作用和用法。

errorlevel 常用来判断上条命令的执行情况。因此我们可以先看看 if /?语句的帮助文档。如下
```
C:\Users\SL-zhuji>if /?
执行批处理程序中的条件处理。

IF [NOT] ERRORLEVEL number command
IF [NOT] string1==string2 command
IF [NOT] EXIST filename command

  NOT               指定只有条件为 false 的情况下，Windows 才
                    应该执行该命令。

  ERRORLEVEL number 如果最后运行的程序返回一个等于或大于
                    指定数字的退出代码，指定条件为 true。

  string1==string2  如果指定的文字字符串匹配，指定条件为 true。

  EXIST filename    如果指定的文件名存在，指定条件为 true。

  command           如果符合条件，指定要执行的命令。如果指定的
                    条件为 FALSE，命令后可跟 ELSE 命令，该命令将
                    在 ELSE 关键字之后执行该命令。

ELSE 子句必须出现在同一行上的 IF 之后。例如:

    IF EXIST filename. (
        del filename.
    ) ELSE (
        echo filename. missing.
    )

由于 del 命令需要用新的一行终止，因此以下子句不会有效:

IF EXIST filename. del filename. ELSE echo filename. missing

由于 ELSE 命令必须与 IF 命令的尾端在同一行上，以下子句也
不会有效:

    IF EXIST filename. del filename.
    ELSE echo filename. missing

如果都放在同一行上，以下子句有效:

    IF EXIST filename. (del filename.) ELSE echo filename. missing

如果命令扩展被启用，IF 会如下改变:

    IF [/I] string1 compare-op string2 command
    IF CMDEXTVERSION number command
    IF DEFINED variable command

其中， compare-op 可以是:

    EQU - 等于
    NEQ - 不等于
    LSS - 小于
    LEQ - 小于或等于
    GTR - 大于
    GEQ - 大于或等于

而 /I 开关(如果指定)说明要进行的字符串比较不分大小写。
/I 开关可以用于 IF 的 string1==string2 的形式上。这些
比较都是通用的；原因是，如果 string1 和 string2 都是
由数字组成的，字符串会被转换成数字，进行数字比较。

CMDEXTVERSION 条件的作用跟 ERRORLEVEL 的一样，除了它
是在跟与命令扩展有关联的内部版本号比较。第一个版本
是 1。每次对命令扩展有相当大的增强时，版本号会增加一个。
命令扩展被停用时，CMDEXTVERSION 条件不是真的。

如果已定义环境变量，DEFINED 条件的作用跟 EXIST 的一样，
除了它取得一个环境变量，返回的结果是 true。

如果没有名为 ERRORLEVEL 的环境变量，%ERRORLEVEL%
会扩充为 ERROLEVEL 当前数值的字符串表达式；否则，你会得到
其数值。运行程序后，以下语句说明 ERRORLEVEL 的用法:

    goto answer%ERRORLEVEL%
    :answer0
    echo Program had return code 0
    :answer1
    echo Program had return code 1

你也可以使用以上的数字比较:

    IF %ERRORLEVEL% LEQ 1 goto okay

如果没有名为 CMDCMDLINE 的环境变量，%CMDCMDLINE%
将在 CMD.EXE 进行任何处理前扩充为传递给 CMD.EXE 的原始
命令行；否则，你会得到其数值。

如果没有名为 CMDEXTVERSION 的环境变量，
%CMDEXTVERSION% 会扩充为 CMDEXTVERSION 当前数值的
字串符表达式；否则，你会得到其数值。
```

根据 if 语句的帮助信息,如果我们使用 if errorlevel number command  去使用 errorlevle，它的含义是：如果返回的错误码值大于或等于值的时候，将执行 command 操作。实例：
```bat
@echo off
copu a.txt bak/b.txt
echo errorlevel=%errorlevel%
if errorlevel 0 echo SUCCESS
pause
```

输出结果
```
'copu' 不是内部或外部命令，也不是可运行的程序
或批处理文件。
errorlevel=9009
SUCCESS
请按任意键继续. . .
```

当使用 if %errorlevel%==值 command 句式时，它的含义是：如果返回的错误码值等于值的时候，将执行command操作。实例
```bat
@echo off
copu a.txt bak/b.txt
echo errorlevel=%errorlevel%
if %errorlevel%==0 (
    echo success
) else (
    echo error
)
pause
```

输出结果
```
'copu' 不是内部或外部命令，也不是可运行的程序
或批处理文件。
errorlevel=9009
error
请按任意键继续. . .
```

上面实例中，errorlevle等于9009，并不等于0，因此输出“error”.

一般上一条命令的执行结果返回的值只有两个，“成功”用 0 表示；“失败”用 1 表示；实际上，errorlevle 返回值可以在 0 ~ 255 之间，例如 xcopy 默认的 errorlevle 值就有 5 个，分包表示 5 种执行状态：
- 0 复制文件成功
- 1 未找到复制文件
- 2 用户通过 CTRL C 终止了 xcopy 操作
- 4 出现了初始化错误
- 5 出现了磁盘写入错误

if %ERRORLEVEL% 对数值的比较方法不仅仅限于等于，可以使用参数来控制。比如
```bat
rem 小于或等于
if %ERRORLEVEL% LEQ 1 echo SUCCESS
```

全部的比较参数如下：

- EQU 等于，=
- NEQ 不等于， !=
- LSS 小于，<
- LEQ 小于或等于，<=
- GTR 大于，>
- GEQ 大于或等于，>=

## set命令

本章将介绍批处理中常用的 set 命令，以及 set 命令注意事项。set 命令在编写批处理脚本时使用频率非常高，需要掌握它的用法。

### 语法

set 命令用来显示、设置或删除 cmd.exe 环境变量。语法如下：
```
SET [variable=[string]]
```

参数说明：
- variable 指定环境变量名。
- string 指定要指派给变量的一系列字符串

### 实例

如果要显示当前环境变量，键入不带参数的SET。实例如下：
```
C:\Users\SL-zhuji>set java_home
JAVA_HOME=E:\Program Files\Java\jdk1.8.0_121\

C:\Users\SL-zhuji>set classpath
环境变量 classpath 没有定义
```

上面实例中显示了 java_home 和 classpath 环境变量的值。

#### 如果命令扩展被启用，SET 会如下改变：

可仅用一个变量激活 SET 命令，等号或值显示所有前缀匹配 SET 命令已使用的名称的所有变量的值。例如
```
C:\Users\SL-zhuji>set p
Path=C:\Program Files\Eclipse Foundation\jdk-8.0.302.8-hotspot\bin;C:\ProgramData\Oracle\Java\javapath;C:\Windows\system32;C:\Windows;C:\Windows\System32\Wbem;C:\Windows\System32\WindowsPowerShell\v1.0\;C:\Windows\System32\OpenSSH\;C:\Program Files (x86)\NVIDIA Corporation\PhysX\Common;C:\Program Files\NVIDIA Corporation\NVIDIA NvDLISR;C:\Program Files\TortoiseSVN\bin;C:\Program Files (x86)\GtkSharp\2.12\bin;E:\Program Files\Java\jdk1.8.0_121\\bin;E:\AndroidSdk\AndroidSDK\tools;E:\AndroidSdk\AndroidSDK\platform-tools;C:\Program Files\Git\cmd;C:\Program Files\nodejs\;E:\AndroidSdk\AndroidSDK;E:\AndroidSdk\AndroidSDK\build-tools\30.0.3;C:\Program Files\Microsoft SQL Server\130\Tools\Binn\;E:\putty\;C:\Users\SL-zhuji\AppData\Local\Programs\Python\Python39\;C:\Users\SL-zhuji\AppData\Local\Programs\Python\Python39\Scripts\;C:\Python27\;C:\Python27\Scripts\;C:\Program Files\dotnet\;E:\Program Files\GSDK-Hub;E:\AndroidNDK\android-ndk-r19c\toolchains\aarch64-linux-android-4.9\prebuilt\windows-x86_64\bin;e:\Ruby30-x64\bin;e:\Ruby23-x64\bin;C:\Users\SL-zhuji\AppData\Local\Microsoft\WindowsApps;E:\Program Files\JetBrains\IntelliJ IDEA Community Edition 2021.1.1\bin;;E:\Program Files\Microsoft VS Code\Microsoft VS Code\bin;C:\Program Files\nodejs\node_global;E:\Program Files\JetBrains\PyCharm Community Edition 2021.2\bin;;C:\Users\SL-zhuji\AppData\Local\GitHubDesktop\bin;C:\Users\SL-zhuji\.dotnet\tools
PATHEXT=.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC;.RB;.RBW
PROCESSOR_ARCHITECTURE=AMD64
PROCESSOR_IDENTIFIER=Intel64 Family 6 Model 165 Stepping 5, GenuineIntel
PROCESSOR_LEVEL=6
PROCESSOR_REVISION=a505
ProgramData=C:\ProgramData
ProgramFiles=C:\Program Files
ProgramFiles(x86)=C:\Program Files (x86)
ProgramW6432=C:\Program Files
PROMPT=$P$G
PSModulePath=C:\Program Files\WindowsPowerShell\Modules;C:\Windows\system32\WindowsPowerShell\v1.0\Modules
PUBLIC=C:\Users\Public
PyCharm Community Edition=E:\Program Files\JetBrains\PyCharm Community Edition 2021.2\bin;
```

会显示所有以字母 P 打头的变量。如果在当前环境中找不到该变量名称， SET 命令将把 ERRORLEVEL 设置成 1 。如下
```bat
@echo off
set PATH
echo errorlevel=%errorlevel%
set NOT_HA_HA
echo errorlevel=%errorlevel%
pause
```

输出结果
```
Path=C:\Program Files\Eclipse Foundation\jdk-8.0.302.8-hotspot\bin;C:\ProgramData\Oracle\Java\javapath;C:\Windows\system32;C:\Windows;C:\Windows\System32\Wbem;C:\Windows\System32\WindowsPowerShell\v1.0\;C:\Windows\System32\OpenSSH\;C:\Program Files (x86)\NVIDIA Corporation\PhysX\Common;C:\Program Files\NVIDIA Corporation\NVIDIA NvDLISR;C:\Program Files\TortoiseSVN\bin;C:\Program Files (x86)\GtkSharp\2.12\bin;E:\Program Files\Java\jdk1.8.0_121\\bin;E:\AndroidSdk\AndroidSDK\tools;E:\AndroidSdk\AndroidSDK\platform-tools;C:\Program Files\Git\cmd;C:\Program Files\nodejs\;E:\AndroidSdk\AndroidSDK;E:\AndroidSdk\AndroidSDK\build-tools\30.0.3;C:\Program Files\Microsoft SQL Server\130\Tools\Binn\;E:\putty\;C:\Users\SL-zhuji\AppData\Local\Programs\Python\Python39\;C:\Users\SL-zhuji\AppData\Local\Programs\Python\Python39\Scripts\;C:\Python27\;C:\Python27\Scripts\;C:\Program Files\dotnet\;E:\Program Files\GSDK-Hub;E:\AndroidNDK\android-ndk-r19c\toolchains\aarch64-linux-android-4.9\prebuilt\windows-x86_64\bin;e:\Ruby30-x64\bin;e:\Ruby23-x64\bin;C:\Users\SL-zhuji\AppData\Local\Microsoft\WindowsApps;E:\Program Files\JetBrains\IntelliJ IDEA Community Edition 2021.1.1\bin;;E:\Program Files\Microsoft VS Code\Microsoft VS Code\bin;C:\Program Files\nodejs\node_global;E:\Program Files\JetBrains\PyCharm Community Edition 2021.2\bin;;C:\Users\SL-zhuji\AppData\Local\GitHubDesktop\bin;C:\Users\SL-zhuji\.dotnet\tools
PATHEXT=.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC;.RB;.RBW
errorlevel=0
环境变量 NOT_HA_HA 没有定义
errorlevel=1
请按任意键继续. . .
```

SET 命令不允许变量名称含有等号。实例：
```bat
@echo off
set PATH=
pause
```

上面实例并不会有任何输出，并且会删除 PATH 环境变量。

### 扩展命令

在 SET 命令中添加了两个新命令行开关：
```bat
rem /A 指定 expression 为数字表达式
SET /A expression
rem promptString 为提示字符串
SET /p variable=[promptString]
```

#### /A 命令

/A 命令行开关指定等号右边的字符串为被评估的数字表达式。该表达式评估器很简单并以递减的优先权顺序支持下列操作：

                   操作符                      描述
                    ()                         分组
                    ! ~ -                      一元运算符
                    * / %                      算数运算符
                    << >>                      逻辑移位
                    &                          按位“与”
                    ^                          按位“异”
                    |                          按位“或”
        = *= /= %= += -= &= ^= |= <<= >>=      赋值      
                    ,                          表达式分隔符

如果使用任何逻辑或取余操作符，需要将表达式字符串用引号括起来。在表达式中的任何非数字字符串健作为环境变量名称，这些环境变量名称的值已在使用前转换成数字。实例：
```bat
@echo off
rem 使用 /A 执行加法运算 。其：val=32
set /A val=10+22
echo %val%

rem 将 val 环境变量加10，赋值给val2环境变量。其：val2=42
set /A val2=%val%+10
echo %val2%

rem 将 16 使用位移操作符，向右移动一位，移动一位等于除以2。其：val3=8
set /A "val3=16>>1"
echo %val3%

rem 使用分组符号提升加法的优先级，其：val4=18
set /A val4=(0+1+2+3+4+5+6+7+8+9)/5*2
echo %val4%

rem 使用 %% 进行取余运算，其：val5=4
set /A "val5=94%%10"
echo %val5%

pause
```

如果指定了一个环境变量名称，但未在当前环境中定义，那么值将被定义为零。这使你可以使用环境变量值做计算而不用键入那些%符号来得到它们的值。

```bat
@echo off
rem 下面再 set 中使用 tmp 参与运算，但是 tmp 并没有定义
rem 默认 tmp 为 0，因此 val=22
set /A val=tmp+22
echo %val%

rem 下面在 set 中使用 %tmp2% 获取变量 tmp2 的值，因为没有定义 tmp2 变量，
rem 因此抛出 “运算符不存在。” 错误。其中，val2=0
set /A val2=%tmp2%+22
echo %val2%

pause
```
如果 SET /A 在命令脚本外的命令行执行的，那么它显示该表达式的最后值。该分配的操作符在分配的操作符左边需要一个环境变量名称。除十六进制有 0x 前缀，八进制有 0 前缀，数字值为十进位数字。因此，0x12 与 18 和 022 相同。请注意八进制公式可能容易搞混：08 和 09 是无效的数字，因为 8 和 9 不是有效的八进制位数。实例：
```
C:\Users\SL-zhuji>set /a val=1+1
2
C:\Users\SL-zhuji>set /a 1+1
2
C:\Users\SL-zhuji>set /a val=0x4+2
6
C:\Users\SL-zhuji>set /a val=04+02
6
```

#### /P 命令

/P 命令行开关允许将变量数值设成用户输入的一行输入。读取输入行之前，显示指定的 promptString。 promptString 可以是空的。语法：
```
set /P variateName=promptString
```
其中：
- variateName 为变量名
- promptString 为提示字符串，将在DOS窗口中显示

实例：提示用户输入名称
```bat
@echo off
set /p username=请输入姓名：
echo 你的姓名：%username%
pause
```
上面实例中，username 为变量名，“请输入姓名：” 是提示信息，用户能够在DOS窗口看见，且光标停留在提示字符串后面。输出结果：
```
请输入姓名：hhh
你的姓名：hhh
请按任意键继续. . .
```

#### 环境变量替换已如下增强

```
%PATH:str1=str2%
```

会扩展PATH环境变量，用“str2”代替扩展结果中的每个“str1”。实例

```bat
@echo off
set val=hello bat
echo %val%
rem replace
echo %val:bat=CMD%
pause
```

输出结果
```
hello bat
hello CMD
请按任意键继续. . .
```
要有效的从扩展结果中删除所有的 “str1”，“str2” 可以是空的。实例：

```bat
@echo off
set val=hello bat
echo %val%
echo %val:a=%
pause
```

输出结果：
```
hello bat
hello bt
请按任意键继续. . .
```
“str1” 可以以星号打头；在这种情况下，“str1” 会从扩展结果的开始到 str1 剩余部分第一次出现的地方，都一直保持相配。实例：

```bat
@echo off
set val=hello bat hello bat
echo %val%
echo %val:*bat=CMD%
pause
```

输出结果：
```
hello bat hello bat
CMD hello bat
请按任意键继续. . .
```

#### 子字符串

```
%PATH:~10,5%
```
会扩展PATH环境变量，然后只使用在扩展结果中从第11个（偏移量10）字符开始的5个字符。实例：
```bat
@echo off
set val=administrator
echo %val%
echo %val:~5,2%
pause
```

上面实例将截取从6（偏移量5）个字符开始的后面2个字符。输出结果：
```
administrator
is
请按任意键继续. . .
```

如果没有指定长度，则采用默认值，即变量数值的余数。实例：
```bat
@echo off
set val=administrator
echo %val%
echo %val:~5%
pause
```

输出结果:
```
administrator
istrator
请按任意键继续. . .
```

如果两个数字（偏移量和长度）都是负数，使用的数字则是环境变量数值长度加上指定的偏移量或长度。实例：
```bat
@echo off
set val=administrator
echo %val%

rem 提取 val 变量的最后6个字符
echo %val:~-6%

rem 从倒数第6个字符开始，提取两个字符
echo %val:~-6,2%

rem 提取 val 变量的所有字符，除了最后两个
echo %val:~0,-2%

rem 提取倒数第6个字符开始到结尾的字符，除了最后两个字符
echo %val:~-6,-2%

pause
```

输出结果：
```
administrator
trator
tr
administrat
trat
请按任意键继续. . .
```

#### 延迟环境变量

DOS添加了延迟环境变量扩充的支持。该支持默认总是被停用，但也可以通过 CMD.EXE 的 /V 命令行开关启动/停用延迟环境变量。详细信息可以参阅 CMD /?
```
启动 Windows 命令解释器的一个新实例

CMD [/A | /U] [/Q] [/D] [/E:ON | /E:OFF] [/F:ON | /F:OFF] [/V:ON | /V:OFF]
    [[/S] [/C | /K] string]

/C      执行字符串指定的命令然后终止
/K      执行字符串指定的命令但保留
/S      修改 /C 或 /K 之后的字符串处理(见下)
/Q      关闭回显
/D      禁止从注册表执行 AutoRun 命令(见下)
/A      使向管道或文件的内部命令输出成为 ANSI
/U      使向管道或文件的内部命令输出成为
        Unicode
/T:fg   设置前台/背景颜色(详细信息见 COLOR /?)
/E:ON   启用命令扩展(见下)
/E:OFF  禁用命令扩展(见下)
/F:ON   启用文件和目录名完成字符(见下)
/F:OFF  禁用文件和目录名完成字符(见下)
/V:ON   使用 ! 作为分隔符启用延迟的环境变量
        扩展。例如，/V:ON 会允许 !var! 在执行时
        扩展变量 var。var 语法会在输入时
        扩展变量，这与在一个 FOR
        循环内不同。
/V:OFF  禁用延迟的环境扩展。

注意，如果字符串加有引号，可以接受用命令分隔符 "&&"
分隔多个命令。另外，由于兼容性
原因，/X 与 /E:ON 相同，/Y 与 /E:OFF 相同，且 /R 与
/C 相同。任何其他开关都将被忽略。

如果指定了 /C 或 /K，则会将该开关之后的
命令行的剩余部分作为一个命令行处理，其中，会使用下列逻辑
处理引号(")字符:

    1.  如果符合下列所有条件，则会保留
        命令行上的引号字符:

        - 不带 /S 开关
        - 正好两个引号字符
        - 在两个引号字符之间无任何特殊字符，
          特殊字符指下列字符: &<>()@^|
        - 在两个引号字符之间至少有
          一个空格字符
        - 在两个引号字符之间的字符串是某个
          可执行文件的名称。

    2.  否则，老办法是看第一个字符
        是否是引号字符，如果是，则去掉首字符并
        删除命令行上最后一个引号，保留
        最后一个引号之后的所有文本。

如果 /D 未在命令行上被指定，当 CMD.EXE 开始时，它会寻找
以下 REG_SZ/REG_EXPAND_SZ 注册表变量。如果其中一个或
两个都存在，这两个变量会先被执行。

    HKEY_LOCAL_MACHINE\Software\Microsoft\Command Processor\AutoRun

        和/或

    HKEY_CURRENT_USER\Software\Microsoft\Command Processor\AutoRun

命令扩展是按默认值启用的。你也可以使用 /E:OFF ，为某一
特定调用而停用扩展。你
可以在机器上和/或用户登录会话上
启用或停用 CMD.EXE 所有调用的扩展，这要通过设置使用
REGEDIT.EXE 的注册表中的一个或两个 REG_DWORD 值:

    HKEY_LOCAL_MACHINE\Software\Microsoft\Command Processor\EnableExtensions

        和/或

    HKEY_CURRENT_USER\Software\Microsoft\Command Processor\EnableExtensions

到 0x1 或 0x0。用户特定设置
比机器设置有优先权。命令行
开关比注册表设置有优先权。

在批处理文件中，SETLOCAL ENABLEEXTENSIONS 或 DISABLEEXTENSIONS 参数
比 /E:ON 或 /E:OFF 开关有优先权。请参阅 SETLOCAL /? 获取详细信息。

命令扩展包括对下列命令所做的
更改和/或添加:

    DEL or ERASE
    COLOR
    CD or CHDIR
    MD or MKDIR
    PROMPT
    PUSHD
    POPD
    SET
    SETLOCAL
    ENDLOCAL
    IF
    FOR
    CALL
    SHIFT
    GOTO
    START (同时包括对外部命令调用所做的更改)
    ASSOC
    FTYPE

有关特定详细信息，请键入 commandname /? 查看。

延迟环境变量扩展不按默认值启用。你
可以用/V:ON 或 /V:OFF 开关，为 CMD.EXE 的某个调用而
启用或停用延迟环境变量扩展。你
可以在机器上和/或用户登录会话上启用或停用 CMD.EXE 所有
调用的延迟扩展，这要通过设置使用 REGEDIT.EXE 的注册表中的
一个或两个 REG_DWORD 值:

    HKEY_LOCAL_MACHINE\Software\Microsoft\Command Processor\DelayedExpansion

        和/或

    HKEY_CURRENT_USER\Software\Microsoft\Command Processor\DelayedExpansion

到 0x1 或 0x0。用户特定设置
比机器设置有优先权。命令行开关
比注册表设置有优先权。

在批处理文件中，SETLOCAL ENABLEDELAYEDEXPANSION 或 DISABLEDELAYEDEXPANSION
参数比 /V:ON 或 /V:OFF 开关有优先权。请参阅 SETLOCAL /?
获取详细信息。

如果延迟环境变量扩展被启用，
惊叹号字符可在执行时间被用来
代替一个环境变量的数值。

你可以用 /F:ON 或 /F:OFF 开关为 CMD.EXE 的某个
调用而启用或禁用文件名完成。你可以在计算上和/或
用户登录会话上启用或禁用 CMD.EXE 所有调用的完成，
这可以通过使用 REGEDIT.EXE 设置注册表中的下列
 REG_DWORD 的全部或其中之一:

    HKEY_LOCAL_MACHINE\Software\Microsoft\Command Processor\CompletionChar
    HKEY_LOCAL_MACHINE\Software\Microsoft\Command Processor\PathCompletionChar

        和/或

    HKEY_CURRENT_USER\Software\Microsoft\Command Processor\CompletionChar
    HKEY_CURRENT_USER\Software\Microsoft\Command Processor\PathCompletionChar

由一个控制字符的十六进制值作为一个特定参数(例如，0x4
是Ctrl-D，0x6 是 Ctrl-F)。用户特定设置优先于机器设置。
命令行开关优先于注册表设置。

如果完成是用 /F:ON 开关启用的，两个要使用的控制符是:
目录名完成用 Ctrl-D，文件名完成用 Ctrl-F。要停用
注册表中的某个字符，请用空格(0x20)的数值，因为此字符
不是控制字符。

如果键入两个控制
字符中的一个，完成会被调用。完成功能将路径字符串带到光标的左边，
如果没有通配符，将通配符附加到左边，并建立相符的路径列表。然后，
显示第一个相符的路径。
如果没有相符的路径，则发出嘟嘟声，不影响显示。
之后，重复按同一个控制
字符会循环显示相符路径的列表。
将 Shift 键跟控制字符同时按下，会倒着显示列表。
如果对该行进行了任何编辑，并再次按下控制
字符，保存的相符路径的列表会被丢弃，新的
会被生成。如果在文件和目录名完成之间切换，
会发生同样现象。两个控制字符之间的唯一区别是
文件完成字符匹配文件和目录名，
而目录完成字符只符合目录名。
如果文件完成被用于内置式目录命令
(CD、MD 或 RD)，就会使用目录完成。

用引号将相符路径括起来，
完成代码可以正确处理含有空格或其他特殊字符的文件名。
同时，如果备份，然后从行内调用文件完成，
则调用完成时位于光标右方的文字会被
弃用。

需要引号的特殊字符是:
<space>
 &()[]{}^=;!'+,`~
```

- /V:ON ：使用 ! 作为分隔符启动延迟的环境变量扩展。例如，/V:ON 会允许 !var! 在执行时扩展变量 var。var 语法会在输入时扩展变量，这与在一个 FOR 循环内不同。
- /V:OFF ：禁用延迟的环境扩展。

实例：使用 ! 符号来输出变量，但是DOS默认时没有启动延迟环境变量，会原样输出变量名，不会解析变量名。
```bat
@echo off
set val=administrator
echo !val!
pause
```

输出结果：
```
!val!
请按任意键继续. . .
```

此时，我们可以使用 cmd.ext /v:on 启动环境变量延迟，如下：
```
C:\Users\SL-zhuji>cmd /v:on
Microsoft Windows [版本 10.0.19044.1586]
(c) Microsoft Corporation。保留所有权利。

C:\Users\SL-zhuji>g:

G:\>cd mdpro\bat

G:\MDPro\bat>helloworld.bat
administrator
请按任意键继续. . .
```

以下例子说明直接俄变量扩充的问题：
```bat
@echo off
set VAR=before
if "%VAR%" == "before" (
    set VAR=after
    if "%VAR%" == "after" @echo If you see this, it worked
)
pause
```
不会显示消息，因为在读到第一个 IF 语句时，两个 IF 语句中的 %VAR% 会被代替；原因是：它包含 IF 的文体， IF 是一个复合语句。所以，复合语句中的 IF 实际上是比较 “before” 和 “after”，这两者永远不会相等。

同样，以下这个例子也不会达到预期效果：
```bat
@echo off
set LIST=
for %%i in (*) do set LIST=%LIST% %%i
echo %LIST%
pause
```

原因是，它不会再目前的目录中建立一个文件列表，而只是将 LIST 变量设成找到的最后一个文件。这也是因为 %LIST% 在 FOR 语句被读取时，只被扩充了一次；而且，那时的 LIST 变量时空的。
因此，我们真正执行的 FOR 循环是：
```bat
@echo off
for %%i in (*) do set LIST= %%i
pause
```
这个循环继续将 LIST 设成找到的最后一个文件。

延迟环境变量扩充允许您使用一个不同的字符（惊叹号，!）在执行时间扩充环境变量。如果延迟的变量扩充被启用，可以将上面例子写成以下所示，以达到预期效果：

```bat
@echo off
set VAR=before
if "%VAR%" == "before" (
    set VAR=after
    if "!VAR!" == "after" @echo If you see this, it worked
)
set LIST=
for %%i in (*) do set LIST=!LIST! %%i
echo %LIST%
pause
```

输出结果：
```
C:\Users\SL-zhuji>cmd.exe /v:on
Microsoft Windows [版本 10.0.19044.1586]
(c) Microsoft Corporation。保留所有权利。

C:\Users\SL-zhuji>g:

G:\>cd mdpro\bat

G:\MDPro\bat>helloworld.bat
If you see this, it worked
 helloworld.bat
请按任意键继续. . .
```

如果命令扩展被启用，有几个动态环境变量可以被扩展，但不会出现在 SET 显示的变量列表中。每次变量数值被扩展时，这些变量数值都会被动态计算。如果用户用这些名称中任何一个明确定义变量，那个定义会替代下面描述的动态定义：

- %CD% - 扩展到当前目录字符串。
- %DATE% - 用跟 DATE 命令同样的格式扩展到当前日期。
- %TIME% - 用跟 TIME 命令同样的格式扩展到当前时间。
- %RANDOM% - 扩展到 0 和 32767 之间的任意十进制数字。
- %ERRORLEVEL% - 扩展到当前 ERRORLEVEL 数值。
- %CMDEXTVERSION% - 扩展到当前命令处理器扩展版本号。
- %CMDCMDLINE% - 扩展到调用命令处理器的原始命令行。
- %HIGHESTNUMANODENUMBER% - 扩展到此计算机上的最高 NUMA 节点号。

实例：输出我们常见的预定义环境变量。
```bat
@echo off
echo %CD%
echo %DATE%
echo %TIME%
echo %RANDOM%
echo %CMDEXTVERSION%
echo %CMDCMDLINE%
pause
```

输出结果
```
G:\MDPro\bat
2022/09/03 周六
16:51:27.86
10580
2
C:\Windows\system32\cmd.exe /c ""G:\MDPro\bat\helloworld.bat" "
请按任意键继续. . .
```

## setlocal/endlocal 命令

setlocal 和 endlocal 命令是用来定义一个局部区域，这个局部区域中的环境变量任何变化都不会改变原先的环境变量。

### setlocal

MicroSoft官方文档解释：
> Setlocal creates a local scope and endlocal terminates the local scope. Any changes made within the setlocal and endlocal scope are discarded, thereby leaving the original environment unchanged. You can nest these two commands to a maximum of 32 levels. For more information about the setlocal and endlocal commands, see Setlocal and Endlocal

开始批处理文件中环境改动的本地化操作。在执行 setlocal 之后所做的环境改动只限于批处理文件。要还原原先的设置，必须执行 endlocal 。达到批处理文件结尾时，对于该批处理文件的每个尚未执行的 setlocal 命令，都会有一个隐含的 endlocal 被执行。语法：
```
SETLOCAL
```
如果命令扩展被启用，setlocal 会如下改变：
setlocal 批命令现在可以接受可选参数:
- enableextensions / disableextensions  启用或禁用命令处理器扩展。这些参数比 cmd /e:on 或 /e:off 开关有优先权。请参阅 cmd /? 获取详细信息。
- enabledelayedexpansion / disabledelayedexpansion  启用或禁用延缓环境变量扩展。这些参数比 cmd /v:on 或 /v:off 开关有优先权。请参阅 cmd /? 获取详细信息。

无论在 setlocal 命令之前它们的设置是什么，这些修改会一直保留到匹配的 endlocal 命令。

如果有一个参数， setlocal 命令将设置 errorlevel 的值。如果有两个有效参数中的一个，该值则为零。用下列技巧，你可以在批脚本中使用这个来决定扩展是否可用：
```bat
@ECHO OFF
VERIFY OTHER 2>nul
SETLOCAL ENABLEEXTENSIONS
IF ERRORLEVEL 1 echo Unable to enable extensions
pause
```
这个方法之所以有效，是因为在 cmd.exe 的旧版本上，setlocal 未设置 errorlevel 值。具有不正确参数的 verify 命令将 errorlevel值初始化成非零值。

实例1：演示使用 setlocal 和 endlocal 定义局部区域，然后在局部区域中修改 path。
```bat
@echo off
echo before setlocal:
set path
pause
 
setlocal
rem reset environment var path
set path=E:\tools
echo after setlocal and reset path
set path
pause
endlocal
 
echo recovery path by endlocal
set path

pause
```

输出结果
```
C:\Users\Administrator\Desktop>test.bat
before setlocal:
Path=D:\ProgramFiles\Python38-32\Scripts\;D:\ProgramFiles\Python38-32\;D:\...
PATHEXT=.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC;.RB;.RBW;.PY;...
请按任意键继续. . .
after setlocal and reset path
Path=E:\tools
PATHEXT=.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC;.RB;.RBW;.PY;...
请按任意键继续. . .
recovery path by endlocal
Path=D:\ProgramFiles\Python38-32\Scripts\;D:\ProgramFiles\Python38-32\;D:\...
PATHEXT=.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC;.RB;.RBW;.PY;...
请按任意键继续. . .
```

从上例我们可以看到环境变量 PATH 第1次被显示得时候是系统默认路径。被设置成了 “E:\TOOLS” 后显示为 “E:\TOOLS”。但当 endlocal 后我们可以看到他又被还原成了系统的默认路径。但这个设置只在该批处理运行的时候有作用。当批处理运行完成后环境变量 PATH 将会还原。

实例2：使用 enabledelayedexpansion 启动延缓环境变量扩展，利用 for 循环将当前目录下面的文件名称拼接到 LIST 变量中。

```bat
@echo off
setlocal enabledelayedexpansion
set LIST=
for %%i in (*) do set LIST=!LIST! %%i
echo %LIST%
endlocal
pause
```

输出结果：
```
 helloworld.bat
请按任意键继续. . .
 ```

 注意，使用感叹号（!）访问变量，即 !LIST!，而不是 %LIST%。

 ### endlocal

 结束批处理文件中环境改动的本地化操作。在执行 endlocal 之后所做的环境改动不再仅限于批处理文件。批处理文件结束后，原先的设置无法还原。语法：
 ```
 ENDLOCAL
 ```

 如果命令扩展被启用，endlocal 会如下改变：

 - 如果相应的 setlocal 用新的 enableextensions 或 disableextensions 选项启用或停用了命令扩展；那么，在 endlocal 之后，命令扩展的启用/停用状态会还原到执行相应的 setlocal 命令前的状态。

## shift 命令

shift 命令用于更改批处理文件处理参数的方式，如指定起始处理参数的位置等。先使用 shift /? 看看帮助信息：

```
C:\Users\SL-zhuji>shift /?
更改批处理文件中可替换参数的位置。

SHIFT [/n]

如果命令扩展被启用，SHIFT 命令支持/n 命令行开关；该命令行开关告诉
命令从第 n 个参数开始移位；n 介于零和八之间。例如:

    SHIFT /2

会将 %3 移位到 %2，将 %4 移位到 %3，等等；并且不影响 %0 和 %1。
```

实例1：利用 shift 命令动态输出批处理执行时输入的所有参数。

```bat
@echo off
:round
if "%1"=="" goto cmd1
echo 参数：%1
shift
goto round
 
:cmd1
echo 没有获取到参数，结束脚本
goto end
:end

pause
```

输出结果
```
Microsoft Windows [版本 10.0.19044.1586]
(c) Microsoft Corporation。保留所有权利。

C:\Users\SL-zhuji>g:

G:\>cd mdpro\bat

G:\MDPro\bat>helloworld.bat arg1 arg2 arg3
参数：arg1
参数：arg2
参数：arg3
没有获取到参数，结束脚本
请按任意键继续. . .
```

实例2：使用 shift /n 的方式重新设置处理参数的起止位置。

```bat
@echo off
echo 参数1：%1
echo 参数2：%2

pause
```

输出结果
```
G:\MDPro\bat>helloworld.bat arg1 arg2 arg3
参数1：arg1
参数2：arg2
请按任意键继续. . .
```

运行上面实例时，我们传递了3个参数，分别是：arg1 arg2 arg3

如果我们在执行 echo 之前添加 “shift /2” 命令，cmd.exe 将把传递参数的起始位置设置为2，即 %3 移动 %2。代码如下：
```bat
@echo off
shift /2
echo 参数1：%1
echo 参数2：%2

pause
```

输出结果
```
G:\MDPro\bat>helloworld.bat arg1 arg2 arg3
参数1：arg1
参数2：arg3
请按任意键继续. . .
```

实例3：使用 shift命令和批处理子程序实现累加功能。

```bat
@echo off
set sum=0
rem 调用子程序
call :sub sum 1 2 3 4
echo sum=%sum%
pause

rem 定义一个子程序
:sub
set /a %1=%1+%2
shift /2
if not "%2"=="" goto sub
goto :eof

pause
```

输出结果：
```
sum=10
请按任意键继续. . .
```

## 获取磁盘路径 %~dp0

在编写批处理文件时，经常需要获取当前目录路径，然后根据当前路径进行文件定位；我们常用 %cd% 或者 %~dp0 来获取当前路径。

### %cd%

%cd%  扩展到当前目录字符串。需要注意的是，这里的当前目录有可能和脚本实际所在目录不一致。实例：

```bat
@echo off
set basePath=%cd%
echo %basePath%
pause
```

输出结果
```
C:\Users\SL-zhuji>g:
G:\>cd mdpro\bat
G:\MDPro\bat>helloworld.bat
G:\MDPro\bat
请按任意键继续. . .



C:\Users\SL-zhuji>call G:\mdpro\bat\helloworld.bat
C:\Users\SL-zhuji
请按任意键继续. . .
```

%cd% 返回的是当前执行环境目录（如果是DOS窗口，则是DOS窗口里面的路径），并非是 bat 脚本实际所在的路径。


### %~dp0

%~dp0 可以用来获取批处理文件的实际路径，与当前 DOS 环境所在的目录没有关系。其中：
- %~dp0 的 “d” 为 Drive 的缩写，即为驱动器，磁盘；
- %~dp0 的 “p” 为 Path 缩写，即为路径，目录；

我们可以使用 cd 命令转到 %~dp0 返回的目录，不过推荐使用 cd /d %~dp0。原因如下：

```
REM %~dp0 返回的路径带有盘符的，因此执行下面命令失败
C:\Users\Administrator\Desktop>cd D:\test
C:\Users\Administrator\Desktop>
 
REM 实际上，我们进入 D:\test 目录需要两步
REM 第一步：选择盘符
C:\Users\Administrator>D:
 
REM 第二步：进入 D:\test 目录
D:\>cd test
 
REM 使用 cd /d 命令
C:\Users\Administrator>cd /d D:\test
D:\test>
```

实例：获取批处理文件自身磁盘路径。

```bat
@echo off
set basePath=%~dp0
echo %basePath%
pause
```

输出结果：
```
C:\Users\SL-zhuji>call g:/mdpro/bat/helloworld.bat
g:\MDPro\bat\
请按任意键继续. . .


C:\Users\SL-zhuji>cd /d g:mdpro\bat
G:\MDPro\bat>helloworld.bat
G:\MDPro\bat\
请按任意键继续. . .
```

更多选项语法：
- ~0   删除任何引号(")，扩充 %0
- %~d0   仅将 %0 扩充到一个驱动器号
- %~f0   将 %0 扩充到一个完全合格的路径名（“f” 是 file，即文件）
- %~p0   仅将 %0 扩充到一个路径
- %~n0   仅将 %0 扩充到一个文件名（“n” 是 name 文件名）
- %~x0   仅将 %0 扩充到一个文件扩展名
- %~s0   扩充的路径只含有短名（“s” 为 Short，短的）
- %~a0   将 %0 扩充到文件的文件属性（“a” 为 attribute，即属性）
- %~t0   将 %0 扩充到文件的日期/时间（“t” time）
- %~z0   将 %0 扩充到文件的大小（Size 大小）
- %~$PATH:0   查找列在路径环境变量的目录，并将 %0 扩充到找到的第一个完全合格的名称。如果环境变量名未被定义，或者没有找到文件，此组合键会扩充到空字符串

实例：尝试使用的选项，查看每个选项的输出结果。

```bat
@echo off
REM G:
echo %~d0
 
REM G:\MDPro\bat\helloworld.bat
echo %~f0
 
REM \MDPro\bat\
echo %~p0
 
REM helloworld
echo %~n0
 
REM .bat
echo %~x0
 
REM G:\MDPro\bat\helloworld.bat
echo %~s0
 
REM --a--------
echo %~a0
 
REM 2022/09/03 18:08
echo %~t0
 
REM 335
echo %~z0

pause
```

输出结果：

```
G:
G:\MDPro\bat\helloworld.bat
\MDPro\bat\
helloworld
.bat
G:\MDPro\bat\helloworld.bat
--a--------
2022/09/03 18:08
335
请按任意键继续. . .
```

可以组合修饰符来得到多重结果：
- %~dp0    仅将 %0 扩充到一个驱动器号和路径
- %~nx0    仅将 %0 扩充到一个文件名和扩展名
- %~fs0    仅将 %0 扩充到一个带有短名的完整路径名
- %~dp$PATH:0    查找列在路径环境变量的目录，并将 %I 扩充到找到的第一个驱动器号和路径。
- %~ftza0     将 %0 扩充到类似输出线路的 DIR
- %0 为当前批处理文件。如果0换成1为第一个文件，2为第2个

### 总结

%cd% 和 %~dp0 两者均可以获取到当前路径，而 %~dp0 获取的是批处理文件所在目录的路径，%cd% 获取的是当前 DOS 环境的路径。如果批处理文件和执行批处理文件不再同一目录，则 %cd% 返回的路径并不是批处理文件所在目录的路径，而是执行环境当前的路径。

#### %cd% 和 %~dp0 区别：

- 使用范围上的不同

  - %cd% 可以在批处理脚本（bat脚本）、命令行窗口中使用

  - %~dp0 只能在批处理脚本（bat脚本） 中使用

- bat 脚本执行时，两者代表的值是否会变化

  - %cd% 会，因为代表的是当前目录

  - %~dp0 不会，因为代表的是脚本文件在磁盘的位置

# 字符串操作

## 字符串截取操作

截取字符串可以说是字符串处理功能中最常用的一个功能了，能够实现截取字符串中的特定位置的一个或多个字符。语法如下：
```
%variable:~n,m%
```

参数说明：
- variable：要进行操作的变量名称，该变量中放的是字符串；
- n：开始截取字符串的偏移量；如果为正数，则从左边开始；如果为负数，则从右边开始
- m：要截取字符的个数。如果没有指定个数，则采用默认值，即变量数值的余数（余数指剩余个数，如：%variable:~-5% 当前偏移量为倒数第6，将剩下的字符全部截取）。如果两个数字 (偏移量和长度) 都是负数，使用的数字则是字符串长度加上指定的偏移量或长度（参见实例2）。

实例1：演示从左或从右截取字符串，以及截取最后的字符。

```bat
@echo off
set ifo=abcdefghijklmnopqrstuvwxyz0123456789
echo 原字符串:
echo %ifo%

rem abcde
echo 截取前5个字符：
echo %ifo:~0,5%

rem fghijklmnopqrstuvwxyz0123456789
echo 截取第六个字符直到最后一个字符
echo %ifo:~5%

rem 56789
echo 截取最后5个字符：
echo %ifo:~-5%
echo %ifo:~-5,5%

rem abcdefghijklmnopqrstuvwxyz01234
echo 截取第一个到倒数第6个字符：
echo %ifo:~0,-5%

rem defgh
echo 从第4个字符开始，截取5个字符：
echo %ifo:~3,5%

rem wxyz0
echo 从倒数第14个字符开始，截取5个字符：
echo %ifo:~-14,5%
pause
```

输出结果:
```
原字符串:
abcdefghijklmnopqrstuvwxyz0123456789
截取前5个字符：
abcde
截取第六个字符直到最后一个字符
fghijklmnopqrstuvwxyz0123456789
截取最后5个字符：
56789
56789
截取第一个到倒数第6个字符：
abcdefghijklmnopqrstuvwxyz01234
从第4个字符开始，截取5个字符：
defgh
从倒数第14个字符开始，截取5个字符：
wxyz0
请按任意键继续. . .
```

实例2：演示偏移量和长度均为负数。

```bat
@echo off
set ifo=a0123456789
echo 原字符串：%ifo%
echo %ifo:~-8%
echo %ifo:~-8,-7%
echo %ifo:~-8,-6%
echo %ifo:~-8,-5%
echo %ifo:~-8,-4%
echo %ifo:~-8,-3%
echo %ifo:~-8,-2%
echo %ifo:~-8,-1%
 
rem error: ECHO 处于关闭状态。
echo %ifo:~-5,-5%
echo %ifo:~-5,-10%
 
pause
```

输出结果：
```
原字符串：a0123456789
23456789
2
23
234
2345
23456
234567
2345678
ECHO 处于关闭状态。
ECHO 处于关闭状态。
请按任意键继续. . .
```

根据上面实例可知，偏移量为字符串长度加上指定的负数偏移量（11 + -8 = 3），因此从第四个字符开始截取；如果没有指定待截取的长度，则截取到字符串末尾；如果指定的截取长度为负数，则表示将从末尾排除n个字符。如：echo %ifo:~-8,-4% 将从第四个字符串开始截取，并且排除最后4个字符，截取结果为“2345”。

实例3：拆分打印Windows的版本号。

```bat
@echo off
 
FOR /F "tokens=1,2,3,4" %%I IN ('VER') DO (
  set Ver_Temp=%%L
)
echo Windows版本字符串：%Ver_Temp%
 
rem 截取版本
set Ver_Major=%Ver_Temp:~0,2%
set Ver_Minor=%Ver_Temp:~3,1%
set Ver_Build=%Ver_Temp:~-4,3%
 
echo Windows Version:
echo   Major %Ver_Major%
echo   Major %Ver_Minor%
echo   Build %Ver_Build%

pause
```

输出结果：
```
Windows版本字符串：10.0.22000.856]
Windows Version:
  Major 10
  Major 0
  Build 856
请按任意键继续. . .
```

实例4：获取当前时间，然后截取成“*点*分*秒*毫秒”格式。
```bat
@echo off
echo 当前时间：%time%
echo 当前时间：%time:~0,2%点%time:~3,2%分%time:~6,2%秒%time:~9,2%毫秒
pause
```

输出结果：
```
当前时间：23:09:33.15
当前时间：23点09分33秒15毫秒
请按任意键继续. . .
```

## 字符串替换操作

替换字符串，即将某一字符串中的特定字符或字符串替换为给定的字符串。语法如下：
```
%variable:str1=str2%
```

参数说明：
- variable：变量命令，存放字符串。
- str1：被替换的字符串
- str2：替换字符串，将使用该字符串去替换字符串中所有的 str1 字符串。

实例1：将“中国”替换成“中华人民共和国”。

```bat
@echo off
set aa=伟大的中国！我为你自豪！
echo 替换前：%aa%
echo 替换后：%aa:中国=中华人民共和国%
 
echo aa = %aa%
set "aa=%aa:中国=中华人民共和国%"
echo aa = %aa%
 
pause
```

输出结果：
```
替换前：伟大的中国！我为你自豪！
替换后：伟大的中华人民共和国！我为你自豪！
aa = 伟大的中国！我为你自豪！
aa = 伟大的中华人民共和国！我为你自豪！
请按任意键继续. . .
```

实例2：利用字符串替换功能，实现查找字符串是否包含指定的字符串。
```bat
@echo off
set str=Hello, welcome to the article.
echo 原文：%str%
 
rem 判断 str 变量中是否存在 the 字符串
set "tmpStr=%str:the=%"
if "%str%"=="%tmpStr%" (
    echo 很抱歉！没有找到
) else (
    echo 存在字符串 “the”
)
 
pause
```

输出结果：
```
原文：Hello, welcome to the article.
存在字符串 “the”
请按任意键继续. . .
```

## 字符串合并操作

本章节将介绍怎样去将两个或多个字符串进行合并。

其实，合并字符串就是将两个字符串放在一起就可以了。例如：

```bat
@echo off
set str1=Hello
set str2=World
 
rem 直接输出合并后的字符串
echo %str1%%str2%
 
rem 将合并后的字符串放入 str 变量中
set str=%str1%%str2%
echo %str%
 
pause
```

输出结果：
```
HelloWorld
HelloWorld
请按任意键继续. . .
```

实例：利用 for 循环将当前目录和子目录下面的文件路径保存到变量中，然后打印到控制台。

```bat
@echo off
rem 设置变量延迟扩展
if "%OS%"=="Windows_NT" setlocal enabledelayedexpansion
 
rem 将当前目录下面以及子目录下面的目录路径放到 allFile 变量
set "bastPath=%~dp0"
set allFile=
for /r %%i in (*) do (
    set "var=%%i"
    set "allFile=!allFile! !var:%bastPath%=!"
)
echo %allFile%
 
pause
```

输出结果：
```
 HelloWorld.bat
请按任意键继续. . .
```

# if 语句

## if 语句基础

在批处理程序中 if 语句非常有用，本章将仔细根据 if /? 帮助信息来解读 if 语句的基础用法，以及更高级的用法。

```
执行批处理程序中的条件处理。

IF [NOT] ERRORLEVEL number command
IF [NOT] string1==string2 command
IF [NOT] EXIST filename command

  NOT               指定只有条件为 false 的情况下，Windows 才
                    应该执行该命令。

  ERRORLEVEL number 如果最后运行的程序返回一个等于或大于
                    指定数字的退出代码，指定条件为 true。

  string1==string2  如果指定的文字字符串匹配，指定条件为 true。

  EXIST filename    如果指定的文件名存在，指定条件为 true。

  command           如果符合条件，指定要执行的命令。如果指定的
                    条件为 FALSE，命令后可跟 ELSE 命令，该命令将
                    在 ELSE 关键字之后执行该命令。

ELSE 子句必须出现在同一行上的 IF 之后。例如:

    IF EXIST filename. (
        del filename.
    ) ELSE (
        echo filename. missing.
    )

由于 del 命令需要用新的一行终止，因此以下子句不会有效:

IF EXIST filename. del filename. ELSE echo filename. missing

由于 ELSE 命令必须与 IF 命令的尾端在同一行上，以下子句也
不会有效:

    IF EXIST filename. del filename.
    ELSE echo filename. missing

如果都放在同一行上，以下子句有效:

    IF EXIST filename. (del filename.) ELSE echo filename. missing

如果命令扩展被启用，IF 会如下改变:

    IF [/I] string1 compare-op string2 command
    IF CMDEXTVERSION number command
    IF DEFINED variable command

其中， compare-op 可以是:

    EQU - 等于
    NEQ - 不等于
    LSS - 小于
    LEQ - 小于或等于
    GTR - 大于
    GEQ - 大于或等于

而 /I 开关(如果指定)说明要进行的字符串比较不分大小写。
/I 开关可以用于 IF 的 string1==string2 的形式上。这些
比较都是通用的；原因是，如果 string1 和 string2 都是
由数字组成的，字符串会被转换成数字，进行数字比较。

CMDEXTVERSION 条件的作用跟 ERRORLEVEL 的一样，除了它
是在跟与命令扩展有关联的内部版本号比较。第一个版本
是 1。每次对命令扩展有相当大的增强时，版本号会增加一个。
命令扩展被停用时，CMDEXTVERSION 条件不是真的。

如果已定义环境变量，DEFINED 条件的作用跟 EXIST 的一样，
除了它取得一个环境变量，返回的结果是 true。

如果没有名为 ERRORLEVEL 的环境变量，%ERRORLEVEL%
会扩充为 ERROLEVEL 当前数值的字符串表达式；否则，你会得到
其数值。运行程序后，以下语句说明 ERRORLEVEL 的用法:

    goto answer%ERRORLEVEL%
    :answer0
    echo Program had return code 0
    :answer1
    echo Program had return code 1

你也可以使用以上的数字比较:

    IF %ERRORLEVEL% LEQ 1 goto okay

如果没有名为 CMDCMDLINE 的环境变量，%CMDCMDLINE%
将在 CMD.EXE 进行任何处理前扩充为传递给 CMD.EXE 的原始
命令行；否则，你会得到其数值。

如果没有名为 CMDEXTVERSION 的环境变量，
%CMDEXTVERSION% 会扩充为 CMDEXTVERSION 当前数值的
字串符表达式；否则，你会得到其数值。
```

### if 语句

if 语句执行批处理程序中的条件处理。语法：

```
IF [NOT] ERRORLEVEL number command
IF [NOT] string1==string2 command
IF [NOT] EXIST filename command
```

参数说明：
- NOT   将表达式的结果取反。例如：表达式为true，not后就为false。只有条件为 false 的情况下，Windows 才应该执行该命令。
- ERRORLEVEL number   如果最后运行的程序返回一个等于或大于指定数字的退出代码，指定条件为 true。
- string1==string2   如果指定的字符串 string1 等于 string2，条件表达式为 true，执行 if 语句的命令。
- EXIST filename   如果指定的文件名存在，指定条件为 true。
- command   如果符合条件（即表达式为TRUE），指定要执行的命令。如果指定的条件为 FALSE，命令后可跟 ELSE 命令，该命令将在 ELSE 关键字之后执行该命令。

实例：下面通过实例演示上面几种 IF 语句形式的用法。

```bat
@echo off
rem 需要用户输入密码
set /p pwd=请输入密码：
if "%pwd%"=="123456" echo 密码正确
if not "%pwd%"=="123456" echo 错误的密码: %pwd%
 
set file=D:\tmp.txt
if exist %file% echo %file% 文件存在
if not exist %file% echo %file% 文件不存在
 
rem 下面有意将 copy 的目标文件参数不写，导致 copy 执行失败
rem 此时 errorlevel 等于 1，我们使用 “ERRORLEVEL number” 风格来判断拷贝是否成功
rem 用意：测试 “ERRORLEVEL number” %ERRORLEVEL% 的结果大于等于指定值，表达式为true
copy tmp.txt >nul 2>nul
if errorlevel 1 echo errorlevel=%errorlevel% 拷贝失败
if errorlevel 0 echo errorlevel=%errorlevel% 文件拷贝成功
 
ipconfig > nul
if errorlevel 0 echo errorlevel=%errorlevel% 执行成功

pause
```

输出结果：

```
请输入密码：123456
密码正确
D:\tmp.txt 文件不存在
errorlevel=1 拷贝失败
errorlevel=1 文件拷贝成功
errorlevel=0 执行成功
请按任意键继续. . .
```

### if-else 语句

上面简单的介绍了 “if” 语句的基础用法。本节我们将介绍 if-else 语句，该语句用来处理 “如果条件为真，执行语句1；否则，执行语句2”。伪语句：

```
if 条件 == true
    语句1
else
    语句2
```

根据上面伪语句描述，我们可以使用 IF 加 NOT 实现该功能。

实例：用户输入密码，判断密码是否正确。
```bat
@echo off
set /p pwd=请输入密码：
if "%pwd%"=="123456" echo 密码正确
if not "%pwd%"=="123456" echo 错误的密码: %pwd%
pause
```

输出结果：
```
请输入密码：123456
密码正确
请按任意键继续. . .



请输入密码：123455
错误的密码: 123455
请按任意键继续. . .
```

上述实例还可以采用 goto 去实现，因为还未介绍 goto 语法，这里就不使用 goto 实现。虽然使用 if + not 能实现该功能，但是代码看上去不是很优雅。我们可以使用批处理提供的 if-else 语句实现。

ELSE 子句必须出现在同一行上的 IF 之后。语法如下：
```
IF EXIST filename. (
    del filename.
) ELSE (
    echo filename. missing.
)
```

由于 del 命令需要用新的一行终止，因此以下子句不会有效：

```
IF EXIST filename. del filename. ELSE echo filename. missing
```

由于 ELSE 命令必须与 IF 命令的尾端在同一行上，以下子句也不会有效：
```
IF EXIST filename. del filename.
ELSE echo filename. missing
```

如果都放在同一行上，以下子句有效（将 del 语句放入括号中）：
```
IF EXIST filename. (del filename.) ELSE echo filename. missing
```

实例：用户输入密码，判断密码是否正确。
```bat
@echo off
set /p pwd=请输入密码：
if "%pwd%"=="123456" (
    echo 密码正确
) else (
    echo 错误的密码: %pwd%
)

pause
```

输出结果：
```
请输入密码：123456
密码正确
请按任意键继续. . .



请输入密码：123455
错误的密码: 123455
请按任意键继续. . .
```


### if-elseif-else 语句

如果条件分支比较少，使用 if-else 就可以了。但是，如果你遇到条件非常多的怎么处理呢？if-else 也能处理，批处理提供了 if -elseif-else 类似 switch 语句。实例：根据学生输入的成绩给出学生级别。代码如下：
```bat
@echo off
set /p score=输入成绩：
if %score% lss 60 (
    echo 未及格，需要多努力啊!
) else if %score% lss 70 (
    echo 及格，多做题
) else if %score% lss 80 (
    echo 良，加把劲考
) else if %score% lss 90 (
    echo 优，你很优秀，继续保持
) else (
    echo 不是凡人
)
pause
```

输出结果：
```
输入成绩：78
良，加把劲考
请按任意键继续. . .
```

如果你要将 else if 换行，需要在 “)” 后面添加 “^” 符号。如下：
```bat
@echo off
set /p score=输入成绩：
if %score% lss 60 (
    echo 未及格，需要多努力啊!
) ^
else if %score% lss 70 (
    echo 及格，多做题
) ^
else if %score% lss 80 (
    echo 良，加把劲考
) ^
else if %score% lss 90 (
    echo 优，你很优秀，继续保持
) ^
else (
    echo 不是凡人
)
pause
```

输出结果：
```
输入成绩：78
良，加把劲考
请按任意键继续. . .
```


## if 语句扩展

如果命令扩展被启用，IF 会如下改变：

```
IF [/I] string1 compare-op string2 command
IF CMDEXTVERSION number command
IF DEFINED variable command
```

其中， compare-op 可以是：
- EQU - 等于
- NEQ - 不等于
- LSS - 小于
- LEQ - 小于或等于
- GTR - 大于
- GEQ - 大于或等于

而 /I 开关（如果指定）说明要进行的字符串比较不分大小写。/I 开关可以用于 IF 的 string1==string2 的形式上。这些比较都是通用的；原因是，如果 string1 和 string2 都是由数字组成的，字符串会被转换成数字，进行数字比较。实例

```bat
@echo off
if "A" equ "A" echo equ ok
if "A" == "A" echo equ ok
if /I "A" equ "a" echo equ ok
if 100 equ 100 echo equ ok
if 100 == 100 echo equ ok
pause
```

输出结果
```
equ ok
equ ok
equ ok
equ ok
equ ok
请按任意键继续. . .
```

CMDEXTVERSION 条件的作用跟 ERRORLEVEL 的一样，除了它是在跟与命令扩展有关联的内部版本号比较。第一个版本是 1。每次对命令扩展有相当大的增强时，版本号会增加一个。命令扩展被停用时，CMDEXTVERSION 条件不是真的。实例：

```bat
@echo off
echo %CMDEXTVERSION%
if CMDEXTVERSION 2 echo 内部版本号为2
pause
```

输出结果：
```
2
内部版本号为2
请按任意键继续. . .
```

如果已定义环境变量，DEFINED 条件的作用跟 EXIST 的一样，除了它取得一个环境变量，返回的结果是 true。实例：使用 DEFINED 判断变量是否定义

```bat
@echo off
set val=10
if DEFINED val echo val=%val%
if NOT DEFINED val echo 没有定义 val 环境变量
 
if DEFINED myPath echo val=%myPath%
if NOT DEFINED myPath echo 没有定义 myPath 环境变量
pause
```

输出结果：
```
val=10
没有定义 myPath 环境变量
请按任意键继续. . .
```

如果没有名为 ERRORLEVEL 的环境变量，%ERRORLEVEL% 会扩充为 ERROLEVEL 当前数值的字符串表达式；否则，您会得到其数值。运行程序后，以下语句说明 ERRORLEVEL 的用法：
```bat
@echo off
xcopy tmp.txt D:\tmp\tmp.txt
echo ERRORLEVEL=%ERRORLEVEL%
goto answer%ERRORLEVEL%
 
rem xcopy 默认的 errorlevel 值就有5个，分别表示5种执行状态
rem 0 复制文件成功 
rem 1 未找到复制文件 
rem 2 用户通过CTRL C 终止了xcopy操作 
rem 4 出现了初始化错误  
rem 5 出现了磁盘写入错误
:answer0
echo xcopy 复制文件成功
goto end
 
:answer1
echo xcopy 未找到复制文件
goto end
 
:answer2
echo xcopy 用户通过 CTRL C 终止了xcopy 操作
goto end
 
:answer4
echo xcopy 出现了初始化错误
goto end
 
:answer5
echo xcopy 出现了磁盘写入错误
goto end
 
:end

pause
```

输出结果：
```
找不到文件 - tmp.txt
复制了 0 个文件
ERRORLEVEL=4
xcopy 出现了初始化错误
请按任意键继续. . .
```

也可以使用以上的数字比较：
```bat
@echo off
xcopy tmp.txt D:\tmp\tmp.txt
echo ERRORLEVEL=%ERRORLEVEL%
IF %ERRORLEVEL% EQU 0 goto answer0
IF %ERRORLEVEL% EQU 1 goto answer0
IF %ERRORLEVEL% EQU 2 goto answer2
IF %ERRORLEVEL% EQU 4 goto answer4
IF %ERRORLEVEL% EQU 5 goto answer5
 
rem xcopy 默认的 errorlevel 值就有5个，分别表示5种执行状态
rem 0 复制文件成功 
rem 1 未找到复制文件 
rem 2 用户通过CTRL C 终止了xcopy操作 
rem 4 出现了初始化错误  
rem 5 出现了磁盘写入错误
 
:answer0
echo xcopy 复制文件成功
goto end
 
:answer1
echo xcopy 未找到复制文件
goto end
 
:answer2
echo xcopy 用户通过 CTRL C 终止了xcopy 操作
goto end
 
:answer4
echo xcopy 出现了初始化错误
goto end
 
:answer5
echo xcopy 出现了磁盘写入错误
goto end
 
:end

pause
```

输出结果：
```
找不到文件 - tmp.txt
复制了 0 个文件
ERRORLEVEL=4
xcopy 出现了初始化错误
请按任意键继续. . .
```

如果没有名为 CMDCMDLINE 的环境变量，%CMDCMDLINE% 将在 CMD.EXE 进行任何处理前扩充为传递给 CMD.EXE 的原始命令行；否则，您会得到其数值

如果没有名为 CMDEXTVERSION 的环境变量，%CMDEXTVERSION% 会扩充为 CMDEXTVERSION 当前数值的字串符表达式；否则，您会得到其数值。

```bat
@echo off
echo cmdLine=%CMDCMDLINE%
echo version=%CMDEXTVERSION%
pause
```

输出结果：
```
cmdLine=C:\WINDOWS\system32\cmd.exe /c ""D:\MDPro\bat\HelloWorld.bat" "
version=2
请按任意键继续. . .
```

# goto 语句

## goto 语句基础

一般的批处理命令，都是按照自上而下的流程逐行执行的，也就是说，只有第一行的命令执行了之后，才可能执行第二行，第二行执行完之后，再执行第三行……如此依次执行。

如果对不同的情况，需要执行不同的既定操作，若还是按照常规的执行流程的话，是无法完成任务的。这个时候，就需要引入流程跳转的概念，动用流程跳转语句 goto 了。流程跳转的含义是：改变默认的执行顺序，强制跳转到指定的位置执行特定的程序块

### goto 语句基础

在使用 goto 语句之前，我们先执行 “goto /?” 查看 goto 语句的帮助文档：

```
将 cmd.exe 定向到批处理程序中带标签的行。

GOTO label

  label   指定批处理程序中用作标签的文字字符串。

标签必须单独一行，并且以冒号打头。

如果命令扩展被启用，GOTO 会如下改变:

GOTO 命令现在接受目标标签 :EOF，这个标签将控制转移到当前
批脚本文件的结尾。不定义就退出批脚本文件，这是一个容易的
办法。有关能使该功能有用的 CALL 命令的扩展描述，请键入
CALL /?。
```

CALL /?

```
从批处理程序调用另一个批处理程序。

CALL [drive:][path]filename [batch-parameters]

  batch-parameters   指定批处理程序所需的命令行信息。

如果命令扩展被启用，CALL 会如下改变:

CALL 命令现在将卷标当作 CALL 的目标接受。语法是:

    CALL:label arguments

一个新的批文件上下文由指定的参数所创建，控制在卷标被指定
后传递到语句。你必须通过达到批脚本文件末两次来 "exit" 两次。
第一次读到文件末时，控制会回到 CALL 语句的紧后面。第二次
会退出批脚本。键入 GOTO /?，参看 GOTO :EOF 扩展的描述，
此描述允许你从一个批脚本返回。

另外，批脚本文本参数参照(%0、%1、等等)已如下改变:


     批脚本里的 %* 指出所有的参数(如 %1 %2 %3 %4 %5 ...)

     批参数(%n)的替代已被增强。你可以使用以下语法:

         %~1         - 删除引号(")，扩展 %1
         %~f1        - 将 %1 扩展到一个完全合格的路径名
         %~d1        - 仅将 %1 扩展到一个驱动器号
         %~p1        - 仅将 %1 扩展到一个路径
         %~n1        - 仅将 %1 扩展到一个文件名
         %~x1        - 仅将 %1 扩展到一个文件扩展名
         %~s1        - 扩展的路径只含有短名
         %~a1        - 将 %1 扩展到文件属性
         %~t1        - 将 %1 扩展到文件的日期/时间
         %~z1        - 将 %1 扩展到文件的大小
         %~$PATH:1   - 查找列在 PATH 环境变量的目录，并将 %1
                       扩展到找到的第一个完全合格的名称。如果
                       环境变量名未被定义，或者没有找到文件，
                       此修改符会扩展到空字符串

    可以组合修改符来取得多重结果:

        %~dp1       - 只将 %1 扩展到驱动器号和路径
        %~nx1       - 只将 %1 扩展到文件名和扩展名
        %~dp$PATH:1 - 在列在 PATH 环境变量中的目录里查找 %1，
                      并扩展到找到的第一个文件的驱动器号和路径。
        %~ftza1     - 将 %1 扩展到类似 DIR 的输出行。

    在上面的例子中，%1 和 PATH 可以被其他有效数值替换。
    %~ 语法被一个有效参数号码终止。%~ 修定符不能跟 %*
    使用
```

看了上面的帮助文档，是不是一头雾水。下面简单介绍 goto 语句：

```
REM 跳转到 myLabel 标签
goto myLabel
 
REM 语句1（在 myLabel 之前的语句将不会执行）
REM 定义了一个标签
:myLabel
REM 语句2（执行该语句，因为 goto 跳转到了 myLabel 标签）
```

实例：要求用户输入字母（A或B），然后根据用户输入的字母显示不同的提示信息。

```bat
@echo off
setlocal
set /p input=请输入字母A或B：
if "%input%"=="A" goto A
if "%input%"=="B" goto B
echo 您没有输入字母
goto end
REM 定义了一个标签
 
:A
echo 您输入的字母是A
goto end
REM 定义了一个标签
 
:B
echo 您输入的字母是B
goto end
:end

pause
```

输出结果
```
REM 用户输入了 A 字母，程序执行 goto A 语句，跳转到 :A 标签，然后继续执行 goto end，跳转到脚本结尾的 :end 标签

请输入字母A或B：A
您输入的字母是A
请按任意键继续. . .
```

其中：
- :A 和 :B 定义了两个标签，可以使用 goto A 或 goto B 跳转到定义的标签。
- setlocal 用来实现环境变量局部化，当批处理执行完毕后，定义的 input 变量将销毁。

### goto 语句注意事项

1. goto 语句和标签要互相呼应，不能只有 goto 语句而没有相应的标签段；否则，程序将找不到相应的标签段而直接退出。实例：

```bat
@echo off
echo hello bat
goto test
echo www.hxstrive.com
pause
```

上面实例中没有定义 test 标签，因此 goto 语句失败了，直接退出脚本；且没有执行 “echo www.hxstrive.com” 语句。

2. 只有标签段而没有goto语句是允许的，但不能实现流程跳转功能，从代码精简的角度来看，有标签段而没有goto语句，则此标签是多余的，可以精简掉。实例：

```bat
@echo off
echo hello bat
:test
echo www.hxstrive.com
pause
```

输出结果：
```
hello bat
www.hxstrive.com
请按任意键继续. . .
```

上面实例中定义了 :test 标签，但是并没有使用，这不影响程序的正常运行。

3. 若有多个标签段，则需要注意标签段之间是否需要添加合适的退出语句来终止程序继续向下执行，这是很多新手很容易犯错的地方，需要谨慎。实例：

```bat
@echo off
setlocal
set /p input=请输入字符（A或B）：
if "%input%"=="A" goto A
if "%input%"=="B" goto B
echo 您没有输入字母
goto end
 
:A
echo 您输入了字符A
 
:B
echo 您输入了字符B
 
:end

pause
```

输出结果：
```
请输入字符（A或B）：A
您输入了字符A
您输入了字符B
请按任意键继续. . .
```

上面实例中，当输入字母A之后，结果将同时显示 "您输入了字母A" 和 "您输入了字母B" 这两行内容。这是因为批处理是自上而下逐行执行的，即使用 goto 语句跳转之后，在新的位置上，这一执行流程仍然会保持，直到碰上另一个流程跳转语句，执行过程并不会在两个标签段之间自动终止。您可以在标签（:A 和 :B）代码块后面添加 exit 或者 goto end （end 是我们在批处理最后面添加的标签）语句。实例：

```bat
@echo off
setlocal
set /p input=请输入字符（A或B）：
if "%input%"=="A" goto A
if "%input%"=="B" goto B
echo 您没有输入字母
goto end
 
:A
echo 您输入了字符A
goto end
 
:B
echo 您输入了字符B
goto end
 
:end

pause
```

输出结果：
```
请输入字符（A或B）：A
您输入了字符A
请按任意键继续. . .
```

或者使用 exit 语句实现上面实例，会直接退出，代码如下：
```bat
@echo off
setlocal
set /p input=请输入字符（A或B）：
if "%input%"=="A" goto A
if "%input%"=="B" goto B
echo 您没有输入字母
exit
 
:A
echo 您输入了字符A
exit
 
:B
echo 您输入了字符B
exit
```

4. 标签名只可以使用常量，而不能使用变量。实例：

```bat
@echo off
setlocal
REM 使用变量存放标签名
set labelA=:A
set labelB=:B
set /p input=请输入字符（A或B）：
if "%input%"=="A" goto A
if "%input%"=="B" goto B
echo 您没有输入字母
goto end
 
REM 使用变量定义标签名
%labelA%
echo 您输入了字符A
goto end
 
REM 使用变量定义标签名
%labelB%
echo 您输入了字符B
goto end
 
:end

pause
```

输出结果：
```
系统找不到指定的批处理标签 - A
```

5. 若有同名的标签段，将执行位于最顶层的标签段，其后的标签段是否得到执行，将视具体的情况加以处理。实例：

```bat
@echo off
setlocal
set /p input=请输入字符（A或B）：
if "%input%"=="A" goto A
goto end
 
:A
echo (1) 您输入了字符A
 
:A
echo (2) 您输入了字符A
 
:end
pause
```

输出结果：
```
请输入字符（A或B）：A
(1) 您输入了字符A
(2) 您输入了字符A
请按任意键继续. . .
```


# for 语句


## for 语句基础

### for 语句基础

for 语句是对一组文件中的每一个文件执行某个特定命令。基本格式如下：

```
REM 在 CMD 窗口中
FOR %variable IN (set) DO command [command-parameters]
 
REM 在批处理文件中
FOR %%variable IN (set) DO command [command-parameters]
```

参数说明：
-  %variable  指定一个单一字母可替换的参数，该参数用来存放 for 语句每次迭代的数据。
-  (set)   指定一个或一组文件，可以使用通配符。
-  command    指定对每个文件执行的命令。
-  command-parameters    为特定命令指定参数或命令行开关。

> 注意：在批处理程序中使用 FOR 命令时，指定变量请使用 %%variable 而不要用 %variable。变量名称是区分大小写的，所以 %i 不同于 %I。

for 语句依次提取 set 中的每一个元素，把它的值赋予形式变量 variable，带到 do 后的 command2 中参与命令的执行；并且每次只提取一个元素，然后执行一次 do 后的命令语句，而无论这个元素是否被带到 command2 中参与了command2 的运行；当执行完一次 do 后的语句之后，再提取 command1 中的下一个元素，再执行一次 command2，如此循环，直到 command1 中的所有元素都已经被提取完毕，该 for 语句才宣告执行结束。

实例：在 CMD 窗口执行简单的 for 循环。
```
C:\Users\Administrator>for %I in (ABC) do echo %I
 
C:\Users\Administrator>echo ABC
ABC
```


实例：在批处理文件中定义一个非常简单的 for 循环，输出指定的字符串。

```bat
@echo off
for %%I in (ABC) do (
     echo %%I
)
pause
```

如果你习惯将 for 和后面的命令写在一行，可以将上面实例修改如下

```bat
@echo off
for %%I in (ABC) do echo %%I
pause
```

输出结果：
```
ABC
请按任意键继续. . .
```

### for 语句注意事项

for语句的形式变量I，可以换成26个字母中的任意一个，这些字母会区分大小写，也就是说，%%I 和 %%i 会被认为不是同一个变量；形式变量I还可以换成其他的字符，但是，为了不与批处理中的 %0～%9 这 10 个形式变量发生冲突，请不要随意把 %%I 替换为 %%0～%%9 中的任意一个。实例：

```bat
@echo off
for  %%A in (ABC) do echo %%A
for  %%I in (ABC) do echo %%I
for  %%Z in (ABC) do echo %%Z
REM %%J 和 %%j 是不同的两个变量
for  %%J in (ABC) do echo %%j
pause
```

输出结果：
```
ABC
ABC
ABC
%j
请按任意键继续. . .
```

in 和 do 之间的 command1 表示的字符串或变量可以是一个，也可以是多个，每一个字符串或变量，我们称之为一个元素，每个元素之间，用空格键、跳格键、逗号、分号或等号分隔。

实例：演示使用空格、分号、逗号和等号分割 command1。

```bat
@echo off
for  %%I in (A B C) do echo %%I
for  %%I in (A;B;C) do echo %%I
for  %%I in (A,B,C) do echo %%I
for  %%I in (A=B=C) do echo %%I
pause
```

输出结果：
```
A
B
C
A
B
C
A
B
C
A
B
C
请按任意键继续. . .
```

现在，来分析上面代码中 for 语句的执行过程：

1. for语句以空格、分号、逗号和等号为分隔符，把 A,B,C 这个字符串切分成三个元素：A、B和C，由此决定了do后的语句将会被执行3次。
2. 第一次执行过程是这样的：先把 A 这个字符串作为形式变量 I 的值，带入 do 后的语句中加以执行，也就是执行 echo %%I 语句，此时的 I 值为 A，因此，第一次执行的结果，将会在屏幕上显示 A 这个字符串；第二次执行和第一次执行的过程是一样的，只不过此时 I 的值已经被替换为 command1 中的第二个元素了，也就是 B 这个字符串；如此循环，当第三次 echo 执行完毕之后，整条 for 语句才算执行完毕；此时，将执行下一条语句，也就是 pause 命令。


### for 语句实例

使用批处理文件打印当前目录下面所有的文件名称。如下：

```bat
@echo off
for %%i in (*.*) do echo "%%i"
pause
```

输出结果：
```
"HelloWorld.bat"
请按任意键继续. . .
```

使用批处理文件打印当前目录下面所有后缀为 txt 的文件名称。如下：
```bat
@echo off
for %%i in (*.txt) do echo "%%i"
pause
```

## for /D 语句扩展

如果启用命令扩展，则 for 语句支持 /D 扩展，语法如下：

```
FOR /D %variable IN (set) DO command [command-parameters]
```

for语句默认将会匹配文件名。如果添加了 /D 扩展命令，则该 for 语句与目录名匹配，而不与文件名匹配。实例：

```bat
@echo off
 
REM 匹配当前目录下面的文件名
echo 第一个 for 语句
for %%i in (*) do echo "%%i"
 
REM 匹配当前目录下面的目录名
echo 第二个 for 语句
for /D %%i in (*) do echo "%%i"
pause
```

输出结果：
```
第一个 for 语句
"HelloWorld.bat"
第二个 for 语句
"tmp"
请按任意键继续. . .
```


实例：搜索 C 盘下的所有目录，但是不包含子目录。
```bat
@echo off
for /D %%i in (C:/*) do echo "%%i"
pause
```

输出结果:
```
"C:LenovoQMDownload"
"C:Microsoft"
"C:Program Files"
"C:Program Files (x86)"
"C:Repositories"
"C:Users"
"C:Windows"
请按任意键继续. . .
```

实例：搜索当前目录下面的所有目录，但是不包含子目录
```bat
@echo off
for /D %%i in (*) do echo "%%i"
pause
```

输出结果：
```
"tmp"
请按任意键继续. . .
```

## for /R 语句扩展

本章节将介绍 for /R 扩展的用法。/R 语法如下：
```
FOR /R [[drive:]path] %variable IN (set) DO command [command-parameters]
```

将递归进入根目录树 [Drive:]Path，在树的每个目录中执行 for 语句。如果在 /R 后没有指定目录，则认为是当前目录。如果 set 只是一个句点（.），则只枚举目录树。

实例：搜索当前目录下的所有文件。
```bat
@echo off
for /r %%i in (*) do echo %%i
pause
```

输出结果：
```
D:\MDPro\bat\HelloWorld.bat
请按任意键继续. . .
```

运行结果将显示，当前目录下的所有文件以及该目录下所有子目录里的所有文件。

实例：输出 D 盘下面所有的目录
```bat
@echo off
for /r d:/ %%i in (.) do echo %%i
pause
```

输出结果：

```
d:\大话数据结构\.
d:\大话数据结构\源代码\.
d:\大话数据结构\源代码\Windows版\.
d:\大话数据结构\源代码\Windows版\第2章算法\.
d:\大话数据结构\源代码\Windows版\第3章线性表\.
d:\大话数据结构\源代码\Windows版\第4章栈与队列\.
d:\大话数据结构\源代码\Windows版\第5章串\.
d:\大话数据结构\源代码\Windows版\第6章树\.
d:\大话数据结构\源代码\Windows版\第7章图\.
d:\大话数据结构\源代码\Windows版\第8章查找\.
d:\大话数据结构\源代码\Windows版\第9章排序\.
d:\大话数据结构\源代码\非Windows版（MAC,LINUX）\.
d:\大话数据结构\源代码\非Windows版（MAC,LINUX）\第2章算法\.
d:\大话数据结构\源代码\非Windows版（MAC,LINUX）\第3章线性表\.
d:\大话数据结构\源代码\非Windows版（MAC,LINUX）\第4章栈与队列\.
d:\大话数据结构\源代码\非Windows版（MAC,LINUX）\第5章串\.
d:\大话数据结构\源代码\非Windows版（MAC,LINUX）\第6章树\.
d:\大话数据结构\源代码\非Windows版（MAC,LINUX）\第7章图\.
d:\大话数据结构\源代码\非Windows版（MAC,LINUX）\第8章查找\.
d:\大话数据结构\源代码\非Windows版（MAC,LINUX）\第9章排序\.
d:\录音\.
请按任意键继续. . .
```

实例：搜索C盘里所有的扩展名为exe的文件。
```bat
@echo off
for /r c:/ %%i in (*.exe) do echo %%i
pause
```

输出结果：

```
c:\Windows\System32\FXSCOVER.exe
c:\Windows\System32\FXSSVC.exe
c:\Windows\System32\FXSUNATD.exe
c:\Windows\System32\GameBarPresenceWriter.exe
c:\Windows\System32\GamePanel.exe
c:\Windows\System32\GenValObj.exe
c:\Windows\System32\getmac.exe
c:\Windows\System32\gpresult.exe
c:\Windows\System32\gpupdate.exe
c:\Windows\System32\grpconv.exe
c:\Windows\System32\hdwwiz.exe
c:\Windows\System32\help.exe
```

运行结果将显示C盘和C盘里各个文件夹下的exe文件。

实例：搜索 C 盘是否有 notepad.exe 可执行文件。如果存在，则使用 start 启动 notepad.exe 程序。

```bat
@echo off
for /r c:/ %%i in (notepad.exe) do (
    if exist %%i (
        echo 找到了 notepad.exe
        REM 去启动 notepad.exe
        start %%i
        goto end
    )
)
echo 没有找到 notepad.exe
 
:end
```

输出结果：

```
找到了 notepad.exe
请按任意键继续. . .
```

## for /L 语句扩展

本节将介绍 for /L 扩展用法。for /L 用使用给定信息创建序列，语法如下：

```
FOR /L %variable IN (start,step,end) DO command [command-parameters]
```

上面语法中其他指令已经在前面介绍过，for /L 表示以增量形式从 start 以每次增加 step，直到到 end 的一个数字序列。如果 start 小于 end，就会执行该命令。如果迭代变量超过 end，则命令解释程序退出此循环。还可以使用负的 step 以递减数值的方式逐步执行此范围内的值。其他参数说明：

- start：指定创建序列的开始位置
- step：for 语句创建序列时单步距离
- end：指定创建序列结束位置

实例：创建 1~5 的序列。
```bat
@echo off
for /L %%i in (1,1,5) do echo %%i
pause
```

输出结果：
```
1
2
3
4
5
请按任意键继续. . .
```

实例：创建 5~1 的序列。
```bat
@echo off
for /L %%i in (5,-1,1) do echo %%i
pause
```

输出结果：
```
5
4
3
2
1
请按任意键继续. . .
```

实例：start，step 和 end 三者的数值关系。
```bat
@echo off
for /l %%i in (2,2,13) do echo %%i
pause >nul
```

输出结果：
```
2
4
6
8
10
12
```

根据实例输出的结果，可以得出如下结论：
- start > end，即 2 > 13
- 当 step 为正时，start+step 决定 %%i 的最小取值范围，end 决定 %%i 的最大取值范围。
- 当 step 为负时，start+step 决定 %%i 的最大取值范围，end 决定 %%i 的最小取值范围。

实例：使用 for 创建大量的文件夹
```bat
@echo off
for /l %%i in (1,1,10) do (
    md %%i
)
echo finished.
pause >nul
```

输出结果：
```
finished.
```

## for /F 语句扩展

### FOR /F 基础

/F 扩展是 for 语句最常用的、也是最强的命令。主要用来处理文件和一些命令的输出结果。它可以提取文本文件的内容，进行逐行分析和处理。语法：

```
FOR /F ["options"] %variable IN (file-set) DO command [command-parameters]
FOR /F ["options"] %variable IN ("string") DO command [command-parameters]
FOR /F ["options"] %variable IN ('command') DO command [command-parameters]
```

或者，如果有 usebackq 选项：

```
FOR /F ["options"] %variable IN (file-set) DO command [command-parameters]
FOR /F ["options"] %variable IN ("string") DO command [command-parameters]
FOR /F ["options"] %variable IN ('command') DO command [command-parameters]
```

其中，file-set 为一个或多个文件名。for 语句会逐一分析指定的每个文件，打开指定文件、读取并处理文件内容。处理包括读取文件内容，将文件内容逐行读取，然后将每行解析成零或更多的符号（默认使用空格作为分隔符）。

实例：下面是一个简单的 for /F 语句，该实例将逐行读取 test.txt 文件的内容，然后默认使用空格分隔。然后将分隔后的列赋值给 %%i（这里只是将第一列赋值给%%i）。test.txt 文本文件内容如下：

```
姓名  年龄   成绩
张三   28     87
李四   32     92
```

批处理脚本内容如下：
```bat
@echo off
for /F %%i in (test.txt) do (
    echo %%i
)
pause
```

输出结果：
```
姓名
张三
李四
请按任意键继续. . .
```

### for /F 高级选项

for /F 还有很多高级功能，这些功能需要通过设置 "options" 来实现，下面将进行逐一介绍。

#### eol=c

忽略以指定字符开头的行。可以使用该功能跳过注释。

实例：实例通过 “eol=#”指定以“#”开头的行为注释行，忽略这些行，不进行处理。

```
# 用户信息
姓名  年龄   成绩
张三   28     87
李四   32     92
```

批处理脚本代码：

```
@echo off
for /F "eol=#" %%i in (test.txt) do (
    echo %%i
)
pause
```

输出结果：

```
姓名
张三
李四
请按任意键继续. . .
```

#### skip=n

指定在 for 语句解析每个文件时，从文件头部跳过的行数。

实例：使用 skip=2 跳过指定文件的第一行和第二行。
```
# 用户信息
姓名  年龄   成绩
张三   28     87
李四   32     92
```

批处理脚本：
```bat
@echo off
for /F "skip=2" %%i in (test.txt) do (
    echo %%i
)
pause
```

输出结果：
```
张三
李四
请按任意键继续. . .
```

#### delims=xxx

指定分隔符号集，替换 for 语句默认的空格和制表符分隔符号。

实例：使用“delims=#”定义使用井号符分割内容。

```
姓名#年龄#成绩
张三#28#87
李四#32#92
```

批处理脚本：
```bat
@echo off
for /F "delims=#" %%i in (test.txt) do (
    echo %%i
)
pause
```

输出结果：
```
姓名
张三
李四
请按任意键继续. . .
```

实例：可以使用“delims”可以指定多个分隔符，如：“delims=#|,”

```
姓名#年龄#成绩
张三|28|87
李四,32,92
```

批处理脚本：
```bat
@echo off
for /F "delims=#|," %%i in (test.txt) do (
    echo %%i
)
pause
```

输出结果：
```
姓名
张三
李四
请按任意键继续. . .
```

delims 允许指定多个分隔符，如果指定多个分割符号时，你要指定空格，请将空格放置到最后，不要放置到最前面。实例如下：

```
姓名#年龄#成绩
张三|28|87
李四,32,92
赵六 30 78
```

批处理脚本：
```bat
@echo off
REM 错误的方式，如果指定多个分隔符时，不要将空格放置到前面
for /F "delims= #|," %%i in (test.txt) do (
    echo %%i
)
REM 正确的方式，将空格放置到 delims 最后
for /F "delims=#|, " %%i in (test.txt) do (
    echo %%i
)
pause
```

输出结果：
```
此时不应有 #|,"。   
请按任意键继续. . .
```

#### tokens=x,y,m-n

简单的来说就是配置怎样去提取每一行的列，列的数量是根据你配置的 delims 决定了，因为 for 语句将使用 delims 对行进行分割。tokens 语法格式：

- tokens=m 表示提取第m列；
- tokens=m,n 表示提取第m列和第n列；
- tokens=m-n 表示提取第m列至第n列；
- tokens=* 忽略行首的所有空格；
- tokens=m* 提取第m列以后的所有字符，星号表示剩余的字符；

> 注意：输出变量的个数由定义了的tokens决定。在 FOR 语句中显式声明 %%i。使用 tokens= 隐式声明 %%j 和 %%k。只要不会引起试图声明高于字母“z”或“Z”的某个变量，则使用 tokens= 可以指定最多 26 个输出变量。

我们通过实例来演示怎样去使用 tokens ，要解析的文本文件内容如下：

```
姓名|年龄|成绩
张三|28|87
李四|32|92
赵六|30|78
```

使用 tokens=3 提取第三列的数据，对应上面的文本文件为“成绩”列。

```bat
@echo off
for /F "delims=| tokens=3" %%i in (test.txt) do (
    echo %%i
)
pause
```

输出结果：
```
成绩
87
92
78
请按任意键继续. . .
```

使用 tokens=1,3 提取第1列和第3列到变量 %%i 和 %%j。代码如下：
```bat
@echo off
for /F "delims=| tokens=1,3" %%i in (test.txt) do (
    echo %%i ---- %%j
)
pause
```

输出结果：
```
姓名 ---- 成绩
张三 ---- 87  
李四 ---- 92  
赵六 ---- 78  
请按任意键继续. . .
```

使用 tokens=2-3 提取第2列和第3列，并且将提取的值放入 %%a 和 %%b（如果你指定的是 %%a，则 for 将递增的将第二列放入 %%b、第三列放入 %%c……一直递增到z或Z）。

```bat
@echo off
for /F "delims=| tokens=2-3" %%a in (test.txt) do (
    echo %%a ---- %%b
)
pause
```

输出结果：
```
年龄 ---- 成绩      
28 ---- 87
32 ---- 92
30 ---- 78
请按任意键继续. . .
```

使用 tokens=2* 提取第二列即后面的所有列，并且将提取的值放入 %%a 和 %%b。
```bat
@echo off
for /F "delims=| tokens=2*" %%a in (test.txt) do (
    echo %%a ---- %%b
)
pause
```

输出结果：
```
年龄 ---- 成绩      
28 ---- 87
32 ---- 92
30 ---- 78
请按任意键继续. . .
```

使用 tokens=* 忽略行首的所有空格。
```
姓名|年龄|成绩
张三|28|87
李四|32|92
赵六|30|78
```

批处理脚本：
```bat
@echo off
for /F "delims=| tokens=*" %%a in (test.txt) do (
    echo %%a
)
pause
```

输出结果：
```
姓名|年龄|成绩      
张三|28|87
李四|32|92
赵六|30|78
请按任意键继续. . .
```

## for /F 的 usebackq 选项

usebackq 命令的功能和意义不是很明朗，据说是由机器自动添加进去的，因此它变得可有可无，我们写代码时可无，机器执行时可有。但可以肯定的是，启用该选项时，它会改变“FOR /F“解析文本的功能，集合内原有引号功能失效，因此需要变成新的引号。

### usebackq 处理有空格的文件名

```
FOR /F "eol=; tokens=2,3* delims=, " %i in (myfile.txt) do @echo %i %j %k
```

会分析 myfile.txt 中的每一行，忽略以分号打头的那些行，将每行中的第二个和第三个符号传递给 for 函数体，用逗号和/或空格分隔符号。请注意，此 for 函数体的语句引用 %i 来获得第二个符号，引用 %j 来获得第三个符号，引用 %k 来获得第三个符号后的所有剩余符号。对于带有空格的文件名，你需要用双引号将文件名括起来。为了用这种方式来使用双引号，还需要使用 usebackq 选项，否则，双引号会被理解成是用作定义某个要分析的字符串。

%i 在 for 语句中显式声明，%j 和 %k 是通过tokens= 选项隐式声明的。可以通过 tokens= 一行指定最多 26 个符号，只要不试图声明一个高于字母 "z" 或"Z" 的变量。请记住，FOR 变量是单一字母、分大小写和全局的变量；而且，不能同时使用超过 52 个（a-zA-Z 等于 26+26）。

> 注意：如果将上面代码放到批处理脚本运行，需要将 %i 改成 %%i；因为在 CMD 窗口使用一个 %，而在批处理文件中需要使用两个%。

实例：演示文件名带有空格时，使用双引号和不使用双引号的区别。
```bat
@echo off
 
REM 将抛出“系统找不到文件 test”错误
for /F "usebackq" %%a in (test text.txt) do (
    echo %%a
)
 
REM 正确
for /F "usebackq" %%a in ("test text.txt") do (
    echo %%a
)
 
pause
```

输出结果：
```
系统找不到文件 test。
姓名|年龄|成绩
张三|28|87
李四|32|92
赵六|30|78
请按任意键继续. . .
```

### usebackq 处理文本字符串

还可以在 for /F 语句中直接分析字符串，需要使用单引号将 file-set 括起来。这样，该字符串会被当做一个文件中的内容来进行解析。

实例：直接在 file-set 中使用单引号来解析字符串。
```bat
@echo off
 
REM 解析失败
for /F "usebackq tokens=1-3" %%a in ("张三|28|87") do (
    echo %%a
)
 
REM 解析成功
for /F "usebackq tokens=1-3" %%a in ('张三 28 87') do (
    echo %%a
    echo %%b
    echo %%c
)
 
pause
```

输出结果：

```
系统找不到文件 张三|28|87。
张三
28
87
请按任意键继续. . .
```

### usebackq处理 CMD 命令

最后，可以用 FOR /F 命令来分析命令的输出。方法是，将括号之间的 file-set 变成一个反括字符串。该字符串会被当作命令行，传递到一个子 CMD.EXE，其输出会被捕获到内存中，并被当作文件分析。如以下例子所示：

```bat
@echo off
FOR /F "usebackq delims==" %%i IN (`set`) DO (
    echo %%i
)
pause
```

会枚举当前环境中的环境变量名称。输出结果：
```
ALLUSERSPROFILE
APPDATA
ChocolateyInstall
ChocolateyLastPathUpdate
CLASSPATH
... 省略 ...
请按任意键继续. . .
```

### FOR变量增强

FOR 变量已被增强。你可以使用下列选项语法去增强 for 变量：

- %~I    删除任何引号(")，扩展 %I

- %~fI    将 %I 扩展到一个完全合格的路径名

- %~dI    仅将 %I 扩展到一个驱动器号

- %~pI    仅将 %I 扩展到一个路径

- %~nI    仅将 %I 扩展到一个文件名

- %~xI    仅将 %I 扩展到一个文件扩展名

- %~sI    扩展的路径只含有短名

- %~aI    将 %I 扩展到文件的文件属性

- %~tI    将 %I 扩展到文件的日期/时间

- %~zI    将 %I 扩展到文件的大小

- %~$PATH:I    查找列在路径环境变量的目录，并将 %I 扩展到找到的第一个完全合格的名称。如果环境变量名未被定义，或者没有找到文件，此组合键会扩展到空字符串

可以组合修饰符来得到多重结果：

- %~dpI    仅将 %I 扩展到一个驱动器号和路径

- %~nxI    仅将 %I 扩展到一个文件名和扩展名

- %~fsI    仅将 %I 扩展到一个带有短名的完整路径名

- %~dp$PATH:I    搜索列在路径环境变量的目录，并将 %I 扩展到找到的第一个驱动器号和路径

- %~ftzaI    将 %I 扩展到类似输出线路的 DIR


实例：获取每个文件的路径，文件名称，文件大小以及文件扩展名。
```bat
@echo off
FOR %%i IN (*) DO (
    echo PATH=%%~dpi  NAME=%%~nxi  SIZE=%%~zi  EXT=%%~xi
)
pause
```

输出结果：
```
PATH=C:\Users\Administrator\Desktop\bat\  NAME=call.bat  SIZE=0  EXT=.bat  
PATH=C:\Users\Administrator\Desktop\bat\  NAME=for.txt  SIZE=4382  EXT=.txt
PATH=C:\Users\Administrator\Desktop\bat\  NAME=hello.bat  SIZE=25  EXT=.bat
PATH=C:\Users\Administrator\Desktop\bat\  NAME=ping.txt  SIZE=1323  EXT=.txt
PATH=C:\Users\Administrator\Desktop\bat\  NAME=test.bat  SIZE=98  EXT=.bat
PATH=C:\Users\Administrator\Desktop\bat\  NAME=text_content.txt  SIZE=50  EXT=.txt
请按任意键继续. . .
```

# 子程序

## 定义子程序

在批处理程序中可以调用外部可运行程序，比如：exe程序，也可调用其他批处理程序。但是不够方便，如果被调用的程序很多，就显得不够简明了，很繁琐。

在 Windows XP 中，批处理可以调用本程序中的一个程序段，相当于子程序，这些子程序一般放在主程序后面。

子程序调用格式：
```
call :label arguments
```

子程序语法：
```
:label
command1
command2
......
commandn
goto :eof
```

### 子程序参数 %0

在子程序段中，参数 %0 指标签 :label。实例：
```bat
@echo off
call :sub 10
goto end
rem 子程序
 
:sub
echo arg0=%0 arg1=%1
goto :eof
 
:end
pause
```

输出结果：
```
arg0=:sub arg1=10
请按任意键继续. . .
```

### 子程序放置位置

子程序一般放在最后，并且注意在主程序最后要加上 exit 或跳转语句，避免错误的进入子过程。实例：
```bat
@echo off
call :sub 10
 
rem 子程序
:sub
echo arg0=%0 arg1=%1
goto :eof
```

输出结果：
```
arg0=:sub arg1=10
arg0=test.bat arg1=
```

上述实例，在主程序后面并没有添加 exit 或者跳转语句，导致子程序被执行了两次。正确的写法如下：
```bat
echo off
call :sub 10
goto end
 
rem 子程序
:sub
echo arg0=%0 arg1=%1
goto :eof
 
:end
pause
```

输出结果：
```
arg0=:sub arg1=10
请按任意键继续. . .
```

### 子程序的变量

子程序和主程序中的变量都是全局变量，其作用范围都是整个批处理程序。实例：在子程序中设置了 val 变量，然后在主程序中访问。

```bat
@echo off
call :sub 10
echo %val%
goto end
 
rem 子程序
:sub
echo sub program
set val=hello sub
goto :eof
 
:end
pause
```

输出结果：
```
sub program
hello sub
请按任意键继续. . .
```

### 子程序传参

传至子程序的参数在 call 语句中指定，在子程序中用 %1、%2 至 %9 的形式调用，而子程序返回主程序的数据只需在调用结束后直接引用就可以了，当然也可以指定返回变量。

实例：定义一个子程序，向子程序传递参数。子程序则把传递的参数放入到变量中。
```bat
@echo off
call :sub return 你好
echo 子程序返回值：%return%
pause
exit
 
:sub
set %1=%2
goto :eof
```

输出结果：
```
子程序返回值：你好
请按任意键继续. . .
```

上面实例中，“call :sub return 你好” 语句中 call 为关键字；:sub 为子程序名称；return 是一个变量名，将传递给子程序，用来存放参数“你好”；而 “你好” 也是一个参数，同样传递给子程序。上面实例，实际执行如下：
```bat
@echo off
call :sub
echo 子程序返回值：%return%
pause
exit
 
:sub
set return=你好
goto :eof
```

### 实例

实例：要求用户输入一个大于1的数字，然后使用子程序计算 1,2,3,4,.....n 的总和，其中：n为用户输入的数字。如下：

```bat
@echo off
set sum=0
set count=1
set /p maxValue=输入一个数字：
 
rem 调用子程序
call :sub sum %maxValue%
echo 数据求和结果：%sum%
pause
exit
 
rem 子程序
:sub
set /a %1=%1+%count%
if %count% leq %2 (
    set /a count=%count%+1
    goto sub
)
goto :eof
```

输出结果：
```
输入一个数字：10
数据求和结果：66
请按任意键继续. . .
```


# 高级知识

## call 命令

### CALL 命令基础

call 是一个功能强大的命令，它不但可在批处理程序中调用另一个批处理程序，而且还可调用指定标号处后面的所有命令（也可以称为子程序）。语法如下：
```
CALL [drive:][path]filename [batch-parameters]
```
参数说明：
- [Drive:]   指定被调用批处理文件的盘符
- [Path]   指定被调用批处理文件路径
- FileName  指定被调用的批处理文件名，当被调用的批处理文件与正在执行的批处理文件都处于同一目录下时，可以省略盘符及路径；
- batch-parameters   指定批处理程序所需的命令行参数信息；
- /?  在命令提示符显示帮助；

实例：创建两个批处理文件，分别为 test.bat 和 sub.bat。在 test.bat 中调用 sub.bat，不传递任何参数信息。

test.bat 文件内容：
```bat
@echo off
echo test.bat
call sub.bat
call C:\Users\Administrator\Desktop\sub.bat
pause
```

sub.bat 文件内容：
```bat
@echo off
echo sub.bat
```

输出结果：
```
test.bat
sub.bat
sub.bat
请按任意键继续. . .
```

实例：创建两个批处理文件，分别为 test.bat 和 sub.bat。在 test.bat 中调用 sub.bat，传递参数信息。

test.bat 文件内容：
```bat
@echo off
echo test.bat
call sub.bat arg1 arg1
call C:\Users\Administrator\Desktop\sub.bat arg1 arg1
pause
```

sub.bat 文件内容：
```bat
@echo off
echo sub.bat
echo 第一个参数：%1
echo 第二个参数：%2
```

输出结果：
```
test.bat
sub.bat
第一个参数：arg1
第二个参数：arg1
sub.bat
第一个参数：arg1
第二个参数：arg1
请按任意键继续. . .
```

### CALL 语句扩展

如果命令扩展被启用，CALL 会如下改变，CALL 命令可以调用指定标签后面的语句（即调用子程序）。语法是：
```
CALL :label [arguments]
```
参数说明：
- :label  用于指定调用位置的标签，与goto语句中使用的标签类似；
- arguments  对于以 :label 开头的批处理程序（或子程序），指定要传送给其新实例的命令行信息，包括命令行选项、文件名、批处理参数或者变量；
- /?  在命令提示符显示帮助；

实例：在批处理脚本中创建 :sub 标签，然后使用 call :sub 调用该标签。
```bat
@echo off
echo test.bat
call :sub
goto end
 
:sub
echo sub label
goto :eof
:end
 
pause
```

输出结果：
```
test.bat
sub label
请按任意键继续. . .
```

实例：在批处理脚本中创建 :sub 标签，然后使用 call :sub arg1 arg2 调用该标签， 并且指定参数。
```bat
@echo off
echo test.bat
call :sub arg1 arg2
goto end
 
:sub
echo sub label
echo 第一个参数：%1
echo 第二个参数：%2
goto :eof
:end
 
pause
```

输出结果：
```
test.bat
sub label
第一个参数：arg1
第二个参数：arg2
请按任意键继续. . .
```

### CALL 参数扩展

另外，批脚本文本参数（%0、%1、等等）已如下改变：

批脚本里的 %* 指出所有的参数(如 %1 %2 %3 %4 %5 ...)，实例：

test.bat 文件内容：
```bat
@echo off
echo test.bat
call sub.bat arg1 arg2
pause
```

sub.bat 文件内容：
```bat
@echo off
echo sub.bat
echo 参数：%*
```

输出结果：
```
sub.bat
参数：arg1 arg2
请按任意键继续. . .
```

批处理参数（%n）已被增强。您可以使用以下语法：
- %~1    删除引号(")，扩展 %1

- %~f1    将 %1 扩展到一个完全合格的路径名

- %~d1    仅将 %1 扩展到一个驱动器号

- %~p1    仅将 %1 扩展到一个路径

- %~n1    仅将 %1 扩展到一个文件名

- %~x1    仅将 %1 扩展到一个文件扩展名

- %~s1    扩展的路径只含有短名

- %~a1    将 %1 扩展到文件属性

- %~t1    将 %1 扩展到文件的日期/时间

- %~z1    将 %1 扩展到文件的大小

- %~$PATH:1    查找列在 PATH 环境变量的目录，并将 %1 扩展到找到的第一个完全合格的名称。如果环境变量名未被定义，或者没有找到文件，此修改符会扩展到空字符串

可以将增强符组合起来，可取得多重结果：
- %~dp1    只将 %1 扩展到驱动器号和路径

- %~nx1    只将 %1 扩展到文件名和扩展名

- %~dp$PATH:1    在列在 PATH 环境变量中的目录里查找 %1，并扩展到找到的第一个文件的驱动器号和路径。

- %~ftza1    将 %1 扩展到类似 DIR 的输出行。

在上面的例子中，%1 和 PATH 可以被其他有效数值替换。%~ 语法被一个有效参数号码终止。%~ 修定符不能跟 %* 使用。

实例：生成一个临时文件 tmp.txt，先将目录 C:\windows 设置为当前目录，调用子程序进行参数扩展；然后再恢复当前目录，调用子程序；观察参数扩展结果。
```bat
@echo off
echo 产生一个临时文件 > tmp.txt
 
REM 下行先保存当前目录，再将 c:\windows 设为当前目录
pushd c:\windows
call :sub tmp.txt
 
REM 下行恢复前次的当前目录
popd
call :sub tmp.txt
pause
 
del tmp.txt
exit
 
:sub
echo 删除引号： %~1
echo 扩充到路径： %~f1
echo 扩充到一个驱动器号： %~d1
echo 扩充到一个路径： %~p1 
echo 扩充到一个文件名： %~n1
echo 扩充到一个文件扩展名： %~x1
echo 扩充的路径指含有短名： %~s1 
echo 扩充到文件属性： %~a1 
echo 扩充到文件的日期/时间： %~t1 
echo 扩充到文件的大小： %~z1 
echo 扩展到驱动器号和路径：%~dp1
echo 扩展到文件名和扩展名：%~nx1
echo 扩展到类似 DIR 的输出行：%~ftza1
echo.
 
goto :eof
```

输出结果：
```
删除引号： tmp.txt
扩充到路径： c:\Windows\tmp.txt
扩充到一个驱动器号： c:
扩充到一个路径： \Windows\
扩充到一个文件名： tmp
扩充到一个文件扩展名： .txt
扩充的路径指含有短名： c:\Windows\tmp.txt
扩充到文件属性：
扩充到文件的日期/时间：
扩充到文件的大小：
扩展到驱动器号和路径：c:\Windows\
扩展到文件名和扩展名：tmp.txt
扩展到类似 DIR 的输出行：c:\Windows\tmp.txt
 
删除引号： tmp.txt
扩充到路径： C:\Users\Administrator\Desktop\tmp.txt
扩充到一个驱动器号： C:
扩充到一个路径： \Users\Administrator\Desktop\
扩充到一个文件名： tmp
扩充到一个文件扩展名： .txt
扩充的路径指含有短名： C:\Users\ADMINI~1\Desktop\tmp.txt
扩充到文件属性： --a------
扩充到文件的日期/时间： 2020/06/16 13:21
扩充到文件的大小： 19
扩展到驱动器号和路径：C:\Users\Administrator\Desktop\
扩展到文件名和扩展名：tmp.txt
扩展到类似 DIR 的输出行：--a------ 2020/06/16 13:21 19 C:\Users\Administrator\Desktop\tmp.txt
 
请按任意键继续. . .
```

## start 命令

start 命令用来启动一个单独的窗口来运行指定的程序（如：exe 文件）或命令（如：批处理脚本 *.bat）。

在使用 start 之前，先使用 start /? 命令查看 start 的手册信息：

```
C:\Users\SL-zhuji>start /?
启动一个单独的窗口以运行指定的程序或命令。

START ["title"] [/D path] [/I] [/MIN] [/MAX] [/SEPARATE | /SHARED]
      [/LOW | /NORMAL | /HIGH | /REALTIME | /ABOVENORMAL | /BELOWNORMAL]
      [/NODE <NUMA node>] [/AFFINITY <hex affinity mask>] [/WAIT] [/B]
      [command/program] [parameters]

    "title"     在窗口标题栏中显示的标题。
    path        启动目录。
    B           启动应用程序，但不创建新窗口。
                应用程序已忽略 ^C 处理。除非应用程序
                启用 ^C 处理，否则 ^Break 是唯一可以中断
                该应用程序的方式。
    I           新的环境将是传递
                给 cmd.exe 的原始环境，而不是当前环境。
    MIN         以最小化方式启动窗口。
    MAX         以最大化方式启动窗口。
    SEPARATE    在单独的内存空间中启动 16 位 Windows 程序。
    SHARED      在共享内存空间中启动 16 位 Windows 程序。
    LOW         在 IDLE 优先级类中启动应用程序。
    NORMAL      在 NORMAL 优先级类中启动应用程序。
    HIGH        在 HIGH 优先级类中启动应用程序。
    REALTIME    在 REALTIME 优先级类中启动应用程序。
    ABOVENORMAL 在 ABOVENORMAL 优先级类中启动应用程序。
    BELOWNORMAL 在 BELOWNORMAL 优先级类中启动应用程序。
    NODE        将首选非一致性内存结构(NUMA)节点指定为
                十进制整数。
    AFFINITY    将处理器关联掩码指定为十六进制数字。
                进程被限制在这些处理器上运行。

                将 /AFFINITY 和 /NODE 结合使用时，会对关联掩码
                进行不同的解释。指定关联掩码，以便将零位作为起始位置(就如将 NUMA
                节点的处理器掩码向右移位一样)。
                进程被限制在指定关联掩码和 NUMA 节点之间的
                那些通用处理器上运行。
                如果没有通用处理器，则进程被限制在
                指定的 NUMA 节点上运行。
    WAIT        启动应用程序并等待它终止。
    command/program
                如果它是内部 cmd 命令或批文件，则
                该命令处理器是使用 cmd.exe 的 /K 开关运行的。
                这表示运行该命令之后，该窗口
                将仍然存在。

                如果它不是内部 cmd 命令或批文件，则
                它就是一个程序，并将作为一个窗口化应用程序或
                控制台应用程序运行。

    parameters  这些是传递给 command/program 的参数。

注意: 在 64 位平台上不支持 SEPARATE 和 SHARED 选项。

通过指定 /NODE，可按照利用 NUMA 系统中的内存区域的方式
创建进程。例如，可以创建两个完全
通过共享内存互相通信的进程以共享相同的首选 NUMA 节点，
从而最大限度地减少内存延迟。只要有可能，
它们就会分配来自相同 NUMA 节点的
内存，并且会在指定节点之外的处理器上自由运行。

    start /NODE 1 application1.exe
    start /NODE 1 application2.exe

这两个进程可被进一步限制在相同 NUMA 节点内的指定处理器
上运行。在以下示例中，application1 在
节点的两个低位处理器上运行，而 application2
在该节点的其后两个处理器上运行。该示例假定指定节点至少具有四个逻辑处理器。请注意，节点号可更改为该计算机的任何有效节点号，
而无需更改关联掩码。

    start /NODE 1 /AFFINITY 0x3 application1.exe
    启动 /NODE 1 /AFFINITY 0xc application2.exe

如果命令扩展被启用，通过命令行或 START 命令的外部命令
调用会如下改变:

将文件名作为命令键入，非可执行文件可以通过文件关联调用。
    (例如，WORD.DOC 会调用跟 .DOC 文件扩展名关联的应用程序)。
    关于如何从命令脚本内部创建这些关联，请参阅 ASSOC 和
     FTYPE 命令。

执行的应用程序是 32 位 GUI 应用程序时，CMD.EXE 不等应用
    程序终止就返回命令提示符。如果在命令脚本内执行，该新行为
    则不会发生。

如果执行的命令行的第一个符号是不带扩展名或路径修饰符的
    字符串 "CMD"，"CMD" 会被 COMSPEC 变量的数值所替换。这
    防止从当前目录提取 CMD.EXE。

如果执行的命令行的第一个符号没有扩展名，CMD.EXE 会使用
    PATHEXT 环境变量的数值来决定要以什么顺序寻找哪些扩展
    名。PATHEXT 变量的默认值是:

        .COM;.EXE;.BAT;.CMD

    请注意，该语法跟 PATH 变量的一样，分号隔开不同的元素。

查找可执行文件时，如果没有相配的扩展名，看一看该名称是否
与目录名相配。如果确实如此，START 会在那个路径上调用
Explorer。如果从命令行执行，则等同于对那个路径作 CD /D。
```

实例：使用 start 命令启动 notepad.exe 记事本程序。
```bat
@echo off
start notepad.exe
```

实例：使用 start 命令启动一个子脚本，并且设置脚本的 title 为 “Sub Title”。
```bat
@echo off
start "Sub Title" sub.bat
```

实例：以最小化和最大化方式启动记事本 notepad.exe 程序
```bat
@echo off
rem 最小化启动记事本，在任务栏可以看见
start /MIN notepad.exe
rem 最大化启动记事本，当于我们点击了最大化按钮
start /MAX notepad.exe
```

实例：本例使用 /WAIT 实现启动记事本应用程序，并且等待关闭记事本后才结束主批处理脚本。
```bat
@echo off
echo 启动记事本程序
start /WAIT notepad.exe
echo 记事本程序关闭了...
```

实例：运行 start+文件的绝对存储路径打开对应的文件；
```bat
@echo off
start D:\tmp.txt
```

当然我们也可以使用 “start 目录地址” 打开资源管理器，或者使用 “start 网站URL” 通过默认浏览器打开指定的 URL。

## pushd 和 popd 命令

pushd 和 popd 这两个命令一般都是同时使用，下面将分别对这两命令进行介绍。

### pushd 命令

将当前目录的路径保存下来，并且切换到你指定的新目录路径。语法：
```
PUSHD [path | ..]
```
参数说明：
- path   指定你要切换的目标目录路径

如果命令扩展被启用，除了一般驱动器号和路径，PUSHD 命令还接受网络路径。如果指定了网络路径，PUSHD 将创建一个指向指定网络资源的临时驱动器号，然后再用刚定义的驱动器号（前面创建的临时驱动器号）更改当前的驱动器和目录。可以从 Z: 往下分配临时驱动器号，使用找到的第一个没有用过的驱动器号。更多信息可以使用 pushd /? 查看
```
C:\Users\SL-zhuji>pushd /?
保存当前目录以供 POPD 命令使用，然后改到指定的目录。

PUSHD [path | ..]

  path        指定要成为当前目录的目录。

如果命令扩展被启用，除了一般驱动器号和路径，PUSHD
命令还接受网络路径。如果指定了网络路径，PUSHD 将创建一个
指向指定网络资源的临时驱动器号，然后再用刚定义的驱动器
号更改当前的驱动器和目录。可以从 Z: 往下分配临时驱动器
号，使用找到的第一个没有用过的驱动器号。
```

实例：通过 DOS 窗口输入 pushd 命令切换到 D 盘；然后使用 popd 命令，恢复到原来的目录。
```
C:\Users\Administrator>pushd D:\
D:\>popd
C:\Users\Administrator>
```

### popd 命令

该命令用来将当前目录切换到 pushd 命令存储的目录路径。语法：
```
POPD
```

如果命令扩展被启用，从 PUSHD 目录堆栈 POPD 驱动器时，POPD 命令会删除 PUSHD 创建的临时驱动器号。更多信息可以使用 popd /? 查看
```
C:\Users\SL-zhuji>popd /?
更改到 PUSHD 命令存储的目录。

POPD


如果命令扩展被启用，从推目录堆栈 POPD 驱动器时，POPD
命令会删除 PUSHD 创建的临时驱动器号。
```

实例：使用 pushd 切换到 D:\ 盘，然后再次使用 popd 命令切换到执行 pushd  之前的目录。
```bat
@echo off
echo %cd%
pushd "D:\"
echo %cd%
popd
echo %cd%
```

输出结果：
```
C:\Users\Administrator\Desktop\bat
D:\
C:\Users\Administrator\Desktop\bat
```

# 批处理实例大全

## 批处理读取文件内容

本文将学习在批处理中怎样将指定文件的内容读取到批处理的某个变量中，下面通过实例逐一介绍。

实例：将 tmp.txt 文本文件的内容读取到 value 变量中。

先在当前脚本的目录下面创建 tmp.txt 文件，内容如下：
```
Hello Bat
 
你好 Bat
```

编写脚本内容，如下：
```bat
@echo off
rem 将 tmp.txt 文件内容存入 value 变量
set /p value=<./tmp.txt
echo %value%
pause
```

上面脚本将 tmp.txt 文件内容保存到 value 变量，然后再将变量内容打印到控制台.

实例：逐行读取文件内容

在 tmp.txt 文本文件中写入数据。内容如下：
```
zhangsan,28
lisi,33,chengdu
wangwu,34,unknown
```

下面批处理程序将逐行读取文本文件内容，然后每行采用逗号分隔，将处理后的内容存入变量。代码如下：
```bat
@echo off
setlocal enabledelayedexpansion
for /f "tokens=1-3 delims=," %%i in (tmp2.txt) do (
    set name=%%i
    set age=%%j
    set address=%%k
    echo 姓名=!name!   年龄=!age!   家住地址=!address!
)
pause
```

运行结果如下：
```
姓名=zhangsan   年龄=28   家住地址=
姓名=lisi   年龄=33   家住地址=chengdu
姓名=wangwu   年龄=34   家住地址=unknown
请按任意键继续. . .
```

## 批处理调用MySql执行SQL脚本

本节将介绍怎样利用批处理脚本去调用 mysql 执行 sql 脚本。

背景： 假如你现在正在开发一个系统，而系统版本迭代很快。每个版本都有对应的数据库SQL脚本，而我们将每个版本的数据库脚本使用名为“版本-日期.sql”的文件进行保存。当我们版本变多时，sql文件也就将变多。

![](/images/Bat/bat1.jpg)

1.0.0-*.sql ~ 1.2.0-*.sql 为每个版本的数据库 SQL 脚本。version.txt 文件中保存当前软件数据库版本；run.bat 保存批处理脚本；

需求：每次初始化/更新数据库时我们只需要执行 run.bat 脚本，然后根据 version.txt 中保存的当前软件版本信息，动态选择需要执行那些 sql。例如：当前版本为 1.1.2，当我们执行 run.bat 时，将数据库从 1.1.2 版本升级到最新版本（即 1.2.0）；

run.bat 脚本内容如下：
```bat
@echo off
if "%OS%" == "Windows_NT" setlocal enabledelayedexpansion
set "CURRENT_DIR=%cd%"
 
rem 数据库名称
set dbName=test
rem 数据库用户名
set dbUsername=root
rem 数据库密码
set dbPassword=XM_zm2019
 
rem 进入到批处理文件所在的目录
cd /d %~dp0
if not "%MYSQL_HOME%" == "" goto gotHome
rem 如果没有定义 MYSQL_HOME 环境变量，则将当前目录设置为 MySQL 主目录
set "MYSQL_HOME=%CURRENT_DIR%"
rem 判断 mysql.exe 和 mysqldump.exe 是否存在
if exist %MYSQL_HOME%\bin\mysql.exe (
    if exist %MYSQL_HOME%\bin\mysqldump.exe goto okExec
)
rem 如果还是没有找到 mysql.exe 和 mysqldump.exe
rem 则将 MYSQL_HOME 设置为默认目录 D:\mysql-5.7.24-winx64
set "MYSQL_HOME=D:\mysql-5.7.24-winx64"
 
:gotHome
rem 判断 mysql.exe 和 mysqldump.exe 是否存在
if exist %MYSQL_HOME%\bin\mysql.exe (
    if exist %MYSQL_HOME%\bin\mysqldump.exe goto okExec
)
echo mysql.exe 和 mysqldump.exe 不存在
goto END
 
:okExec
set "exe_mysql=%MYSQL_HOME%\bin\mysql.exe"
set "exe_mysqldump=%MYSQL_HOME%\bin\mysqldump.exe"
 
echo exe_mysql        %exe_mysql%
echo exe_mysqldump    %exe_mysqldump%
 
rem 检查 MySql 服务是否启动，如果没有启动直接退出
tasklist /NH | findstr /i "mysqld.exe" > nul && goto okScript
echo 检测到 MySql 服务未启动，请先启动 MySql 服务
goto END
 
:okScript
rem 提示用户是否备份
cd /d %~dp0
set /p is_bk=是否备份数据库(Y/N)：
if "%is_bk%"=="Y" goto okBackup
if "%is_bk%"=="y" goto okBackup
goto oKImport
 
:okBackup
echo 数据库备份开始......
set last_script_name=%date:~0,10%
if not exist %cd%\db_bak (
    mkdir %cd%\db_bak
)
%exe_mysqldump% -u%dbUsername% -p%dbPassword% -R test > "%cd%\db_bak\bk_%last_script_name:/=-%_%time:~0,2%%time:~3,2%%time:~6,2%.sql"
if not "%errorlevel%"=="0" (
    echo ERROR: 备份数据库失败, CODE=%errorlevel%
    goto END
)
echo 脚本备份完成，文件：bk_%last_script_name:/=-%.sql
 
rem 开始导入数据库脚本
:oKImport
set /p version=<version.txt
if "%version%" equ "" (
    set version=0.0.0
    set continueInfo=全新安装数据库脚本
    goto continueConfirm
)
set continueInfo=从%version%版本升级到最新版数据库脚本
 
:continueConfirm
set /p continueFlag=%continueInfo%。确定要继续吗(Y/N)：
if "%continueFlag%" equ "Y" goto startRun
if "%continueFlag%" equ "y" goto startRun
echo 不进行数据库脚本升级
goto END
 
:startRun
set currentVersion=%version:.=%
echo mysql脚本初始化开始......
for %%i in (*.sql) do (
    set "fileName=%%i"
    set "filePrefix=!fileName:.=!"
    set "prefixNum=!filePrefix:~0,3!"
    if !prefixNum! gtr %currentVersion% (
        echo 初始化脚本 -------- %%i
        %exe_mysql% -u%dbUsername% -p%dbPassword% < %%i
    )
)
echo mysql脚本初始化结束，时间：%date:~0,4%-%date:~5,2%-%date:~8,2% %time:~0,2%:%time:~3,2%:%time:~6,2%
 
:END
pause
```

运行：
将 version.txt 文件的内容清空，然后执行 run.bat 脚本。运行结果如下：
![](/images/Bat/bat2.jpg)

将 version.txt 文件的内容设置为 1.1.2，然后执行 run.bat 脚本。运行结果如下：
![](/images/Bat/bat3.jpg)