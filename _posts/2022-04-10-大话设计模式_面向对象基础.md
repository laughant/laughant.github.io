## 类与实例

### 类

- 类就是具有相同的属性和功能功能的对象的抽象的集合。
- 类名首字母要大写。多个单词则各个首字母大写。
- 对外公开的方法需要用 public 修饰符

### 实例

- 实例就是一个真是的对象，而实例化就是创建对象的过程。

## 构造方法

- 构造方法又叫构造函数，作用是对类进行初始化。
- 构造方法与类同名，无返回值，也不需要 void，在 new 时调用。
- 所有类都有构造方法，如果不编码则系统会默认生成空的构造方法，若有定义的构造方法，那么默认的构造方法就会失效。
- 可以将构造方法重载

## 方法重载

- 方法重载提供了创建多个同名方法的能力，但这些方法需要使用不同的参数类型。
- 不仅构造方法可以重载，普通方法也可以重载。
- 方法重载时，两个方法必须要方法名相同，但参数类型或个数必须要有所不同。
- 方法重载可以在不改变原方法的基础上，新增功能。

## 属性与修饰符

- 属性是一个方法或一对方法，但在调用它的代码看来，它是一个字段，即属性适合于以字段的方式使用方法调用的场合。
- 字段是存储类要满足其设计所需要的数据，字段是与类相关的变量。
- public 表示它所修饰的类成员可以允许其他任何类来访问，俗称公有的。
- private 表示只允许同一个类中的成员访问，其他类包括它的子类无法访问，俗称私有的。
- protected 表示继承时子类可以对基类有完全访问权，也就是说，用 protected 修饰的类成员，对子类公开，但不对其他类公开。
- 通常字段都是 private，即私有变量；而属性都是 public，即公有变量。
- 由于是对外的，属性的名称一般首字母大写，而字段则一般首字母小写或前加“_”。
- 属性有两个方法 get 和 set。get 访问器返回与声明的属性相同的数据类型。表示的意思是调用时可以得到的内部字段的值或引用；set 访问器没有显示设置参数，但它有一个隐式参数，用关键字 value 表示，它的作用时调用属性时可以给内部的字段或引用赋值。
- 修饰符CSDN解释
- public ：访问不受限制。
- protected ：访问限于当前程序集或派生自包含类的类型。
- internal ：访问限于当前程序集。
- protected internal ：访问限于当前程序集或派生自包含类的类型。
- private ：访问限于包含类。
- private protected ：访问限于包含类或当前程序集中派生自包含类的类型。

## 封装

每个对象都包含他能进行操作所需要的所有信息，这个特性称为封装，因此对象不必依赖其他对象来完成自己的操作。
- 良好的封装能够减少耦合。
- 类内部的实现可以自由地修改。
- 类具有清晰的对外接口

## 继承

- 对象的继承代表了一种 'is-a' 的关系，如果两个对象A和B，可以描述为'B 是 A',则表明 B 可以继承 A。
- 继承者还可以理解为是对被继承者的特殊化，因为它除了具备被继承者的特性外，还具备自己独有的个性。
- 继承定义了类如何相互关联，共享特性。
- 继承的工作方式是，定义父类和子类，或叫做基类和派生类，其中子类继承父类的所有特性。子类不但继承了父类的所有特性，还可以定义新的特性。
- 学习继承最好记住三句话：
  1. 子类拥有父类非 private 的属性和功能。
  2. 子类具有自己的属性和功能，即子类可以扩展父类没有的属性和功能。
  3. 子类可以以自己的方式实现父类的功能（方法重写）。
- 在c#中，子类从它的父类中继承的成员有方法、域、属性、事件、索引器，但对于构造方法，有一些特殊性，它不能被继承，只能被调用。对于调用父类的成员，可以用 base 关键字。
- 不用继承的话，如果要修改功能，就必须在所有重复的方法中修改，代码越多，出错的可能就越大。
- 继承的优点是，继承使得所有子类公共的部分都放在了父类，使得代码得到了共享，这就避免了重复，另外，继承可使得修改或扩展继承而来的实现都较为容易。
- 继承是有缺点的，那就是父类变，则子类不得不变。继承会破坏包装，父类实现细节暴露给子类，这其实是增大了两个类之间的耦合性。
- 继承显然是一种类与类之间强耦合的关系。
- 当两个类具备 ‘is - a’的关系时，就可以考虑使用继承，因为这表示一个类是另一个类的特殊种类，而当两个类之间是 ‘has - a’的关系时，表示某个角色具有某一项责任，此时不合适用继承。如人有两只手，手不能继承人；如飞机场有飞机，飞机不能继承机场。

## 多态

多态表示不同的对象可以执行相同的动作，但要通过它们自己的实现代码来执行。
对象的声明必须是父类，而不是子类，实例化的对象是子类，这才能实现多态。
如：
```
Animal[] arrayAnimal = new Animal[5];
arrayAnimal[0] = new Cat("小花");
arrayAnimal[1] = new Dog("阿毛");
arrayAnimal[2] = new Dog("小黑");
arrayAnimal[3] = new Cat("咪咪");
arrayAnimal[4] = new Cat("哈哈");
```
- 注意点：
  1. 子类以父类的身份出现。
  2. 子类在工作时以自己的方式来实现。
  3. 子类以父类的身份出现时，子类特有的属性和方法不可以使用。
- 为了使子类的实例完全接替来自父类的类成员，父类必须将该成员声明为虚拟的。这是通过在该成员的返回类型之前添加 virtual 关键字来实现。子类可以选择使用 override 关键字，将父类实现替换为它自己的实现，这就是方法重写 Override，或者叫做方法覆盖。
- 多态的原理是，当方法被调用时，无论对象是否被转换为其父类，都只有位于对象继承链最末端的方法实现会被调用。也就是说，虚方法是按照其运行时类型而非编译时类型进行动态绑定调用的。

## 重构

## 抽象类

c#允许把类和方法声明为 abstract，即抽象类和抽象方法。

- 抽象类不能实例化。
- 抽象方法是必须被子类重写的方法，抽象方法可以被看成是没有实现体的虚方法。
- 如果类中包含抽象方法，那么类就必须定义为抽象类，不论是否还包含其他一般方法。
- 要让抽象类拥有尽可能多的共同代码，拥有尽可能少的数据。
- 抽象类通常代表一个抽象概念，它提供一个继承的出发点，当设计一个新的抽象类时，一定是用来继承的，所以，在一个以继承关系形成的等级结构里面，树叶节点应当是具体类，而树枝节点均应当是抽象类。

## 接口

接口是把隐式公共方法和属性组合起来，以封装特定功能的一个集合。
- 一旦类实现了接口，类就可以支持接口所指定的所有属性和成员。
- 声明接口在语法上与声明抽象类完全相同，但不允许提供接口中任何成员的执行方式。
- 接口不能实例化。
- 不能有构造方法和字段。
- 不能有修饰符，比如 public 、 private 等。
- 不能声明虚拟的或静态的等。
- 实现接口的类就必须要实现接口中的所有方法和属性。
- 一个类可以支持多个接口，多个类也可以支持相同的接口。
- 接口的命名，前面要加一个大写字母‘I’，这是规范。
- 接口用 interface 声明，而不是 class，接口名称前要加 ‘I’，接口中的方法或属性前面不能有修饰符，方法没有方法体。

## 抽象类和接口的区别

- 从形态上区分

1. 抽象类可以给出一些成员的实现，接口不包含成员的实现。
2. 抽象类的抽象成员可被子类部分实现，接口的成员需要实现类完全实现。
3. 一个类只能继承一个抽象类，但可实现多个接口。

- 类是对对象的抽象；抽象类是对类的抽象；接口是对行为的抽象。

    - 接口是对类的局部（行为）进行的抽象，而抽象类是对类整体（字段、属性、方法）的抽象。
    - 如果只关注行为抽象，那么也可以认为接口就是抽象类。
    - 不论是接口、抽象类、类甚至对象，都是在不同层次、不同角度进行抽象的结果，它们的共性就是抽象。

- 如果行为跨越不同类的对象，可使用接口；对于一些相似的类对象，用继承抽象类。

    - 比如猫狗都是动物，它们之间又很多相似的地方，所以我们应该让它们去继承动物这个抽象类，而飞机、麻雀、超人是完全不相关的类，叮当是动漫角色，孙悟空是神话人物，这也是不相关的类，但它们又是有共同点的，前三个都会飞，而后两个都会变出东西，所以此时让它们去实现相同的接口来达到我们的设计目的就很合适。实现接口和继承抽象类并不冲突。

- 从设计角度讲，抽象类是从子类中发现了公共的东西，泛化出父类，然后子类继承父类，而接口是根本不知子类的存在，方法如何实现还不确定，预先定义。

## 集合

### 数组

- 优点：数组在内从中连续存储，因此可以快速而容易地从头到尾遍历元素，可以快速修改元素等等。
- 缺点：创建时必须要指定数组变量的大小，还有在两个元素之间添加元素也比较困难。数组长度设置过大，容易造成内存空间浪费，设置过小造成溢出。

### 集合

.NET Framework提供了用于数据存储和检索的专用类，这些类统称集合。这些类提供对堆栈、队列、列表和哈希表的支持。大多数集合类实现相同的接口。

#### ArrayList

- ArrayList是命名空间System.Collections下的一部分，它是使用大小可按需动态增加的数组实现IList接口。
- ArrayList的容量是ArrayList可以保存的元素数。
- ArrayList的默认初始容量为0。随着元素添加到ArrayList中，容量会根据需要通过重新分配自动增加。
- 使用整数索引可以访问此集合中的元素。此集合中的索引从零开始。
- ArrayList不是类型安全的。还有就是ArrayList对于存放值类型的数据，比如 int、string型或者结构 struct 的数据，用 ArrayList 就意味着都需要将值类型装箱为 Object对象，使用集合元素时，还需要执行拆箱操作，这就带来了很大的性能损耗。
- 装箱就是把值类型打包到 Object 引用类型的一个实例中。比如整型变量 i 被“装箱”并赋值给对象o

```
int i = 123;
object o = (object) i; // boxing
```
- 拆箱就是指从对象中提取值类型。

```
o = 123;
i = (int) o;  // unboxing
```
- 相对于简单的赋值而言，装箱和拆箱过程需要进行大量的计算。对值类型进行装箱时，必须分配并构造一个全新的对象。其次，拆箱所需的强制转换也需要进行大量的计算。

## 泛型

- 泛型是具有占位符（类型参数）的类、结构、接口和方法，这些占位符是类、结构、接口和方法所存储或使用的一个或多个类型的占位符。
- 泛型集合类可以将类型参数用作它所存储的对象的类型的占位符；类型参数作为其字段的类型和其方法的参数类型出现。

例子：首先泛型集合需要 System.Collections.Generic 的命名空间。而List类是ArrayList类的泛型等效类。该类使用大小可按需动态增加的数组实现IList泛型接口。其实用法上关键就是在IList和List后面加‘< T >’,这个‘T'就是需要指定的集合的数据或对象类型。
```c#
using System.Collections.Generic;

pubic partial class Form1:Form
{
    IList<Animal> arrayAnimal;

    private void button3_Click(Object sender,EventArgs e)
    {
        arrayAnimal = new List<Animal>();
        arrayAnimal.Add(new Cat("小花"));
        arrayAnimal.Add(new Dog("阿毛"));
    }
}
```
- 通常情况下，都建议使用泛型集合，因为这样可以获得类型安全的直接优点而不需要从基集合类型派生并实现类型特定的成员。此外，如果集合元素为值类型，泛型集合类型的性能通常优于对应的非泛型集合类型（并优于从非泛型基集合类型派生的类型），因为使用泛型时不必对元素进行装箱。

## 委托与事件
- 委托是对函数的封装，可以当作给方法的特征指定一个名称。
- 委托时一种引用方法的类型。一旦为委托分配了方法，委托将与该方法具有完全相同的行为。
- 委托对象用关键字 delegate 来声明。
- 事件则是委托的一种特殊形式，当发生有意义的事情时，事件对象处理通知过程。
- 事件是在发生其他类或对象关注的事情时，类或对象可通过事件通知它们。
- 事件对象用 event 关键字声明。

```c#
class Cat
{
    private string name;
    public Cat(string name)
    {
        this.name = name;
    }

    //声明委托 CatShoutEventHandler
    public delegate void CatShoutEventHandler();

    //声明事件 CatShout,它的事件类型是委托 CatShoutEventHandler
    public event CatShoutEventHandler CatShout;

    public void Shout()
    {
        Console.WriteLine("喵，我是{0}.",name);

        if (CatShout != null)
        {
            //当执行Shout()方法时，如果CatShout中有对象登记事件，则执行CatShout()
            //因为事件CatShout的类型是委托CatShoutEventHandler，而CatShoutEventHandler是无参数、无返回值。
            CatShout();
        }
    }
}

class Mouse
{
    private string name;
    public Mouse(string name)
    {
        this.name = name;
    }

    public void Run()
    {
        Console.WriteLine("老猫来了，{0}快跑.",name);
    }
}

static void Main(string[] args)
{
    Cat cat = new Cat("Tom");
    Mouse mouse1 = new Mouse("Jerry");
    Mouse mouse2 = new Mouse("Jack");

    //表示将 Mouse 的 Run 方法通过实例化委托Cat.CatShoutEventHandler登记到Cat的事件CatShout当中。其中“+=”表示“add_CatShout”的意思
    cat.CatShout += new Cat.CatShoutEvnetHandler(mouse1.Run);
    cat.CatShout += new Cat.CatShoutEvnetHandler(mouse2.Run);
}

```
- EventArgs 是包含事件数据的类的基类。换句话说，这个类的作用就是用来在事件触发时传递数据用的。

```c#
public class CatShotEventArgs:EventArgs
{
    private string name;
    public string Name
    {
        get {return name;}
        set {name = value;}
    }
}

class Cat
{
    private string name;
    public Cat(string name)
    {
        this.name = name;
    }

    public delegate void CatShoutEventHandler(object sender,CatShutEventArgs args);
    public event CatShoutEventHandler CatShout;

    public void Shout()
    {
        Console.WriteLine("喵，我是{0}.",name);
    }

    if (CatShout != null)
    {
        CatShoutEventArgs e = new CatShoutEventArgs();
        e.Name = this.name;
        CatShout(this,e);
    }
}

class Mouse
{
    private string name;
    public Mouse(string name)
    {
        this.name = name;
    }

    public void Run(object sender,CatShoutEventArgs args)
    {
        Console.WriteLine("老猫{0}来了，{1}快跑.",args.Name,name);
    }
}
```

